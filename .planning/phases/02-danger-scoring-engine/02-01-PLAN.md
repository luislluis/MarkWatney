---
phase: 02-danger-scoring-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [trading_bot_smart.py]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Every tick while holding 99c position, a danger score is calculated and stored"
    - "Danger score combines 5 weighted signals: confidence drop, OB imbalance, velocity, opponent ask, time decay"
    - "Each signal weight is a configurable constant"
    - "Danger threshold constant exists (default 0.40)"
  artifacts:
    - path: "trading_bot_smart.py"
      provides: "DANGER_THRESHOLD and 5 DANGER_WEIGHT_* constants"
      contains: "DANGER_THRESHOLD = 0.40"
    - path: "trading_bot_smart.py"
      provides: "get_price_velocity() helper function"
      contains: "def get_price_velocity"
    - path: "trading_bot_smart.py"
      provides: "calculate_danger_score() function"
      contains: "def calculate_danger_score"
  key_links:
    - from: "main loop"
      to: "calculate_danger_score()"
      via: "call when capture_99c_fill_notified is True"
      pattern: "danger_result = calculate_danger_score"
    - from: "calculate_danger_score()"
      to: "window_state['danger_score']"
      via: "assignment after calculation"
      pattern: "window_state\\['danger_score'\\] = danger_result\\['score'\\]"
---

<objective>
Implement the danger scoring engine that calculates a weighted danger score from 5 signals every tick while holding a 99c capture position.

Purpose: Provide the numerical foundation for hedge decisions. Without a danger score, there's no signal to trigger protective hedges.

Output: `calculate_danger_score()` function called every tick, returning a score (0.0+) stored in `window_state['danger_score']`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-tracking-infrastructure/01-01-SUMMARY.md
@.planning/phases/02-danger-scoring-engine/02-RESEARCH.md
@trading_bot_smart.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add danger scoring constants and helper function</name>
  <files>trading_bot_smart.py</files>
  <action>
Add 6 constants near the existing CAPTURE_99C_* constants (around line 265-288):

```python
# Danger Scoring Configuration (for smart hedge)
DANGER_THRESHOLD = 0.40              # Hedge triggers when danger >= this
DANGER_WEIGHT_CONFIDENCE = 3.0       # Weight for confidence drop from peak
DANGER_WEIGHT_IMBALANCE = 0.4        # Weight for order book imbalance against us
DANGER_WEIGHT_VELOCITY = 2.0         # Weight for BTC price velocity against us
DANGER_WEIGHT_OPPONENT = 0.5         # Weight for opponent ask price strength
DANGER_WEIGHT_TIME = 0.3             # Weight for time decay in final 60s
```

Add `get_price_velocity()` helper function near the other 99c capture functions (after `check_99c_capture_hedge()`, around line 1390):

```python
def get_price_velocity(btc_price_history: deque, bet_side: str) -> float:
    """
    Calculate BTC price velocity over the rolling window.
    Returns fractional price change against our position (positive = dangerous).

    For UP position: falling BTC = positive (dangerous)
    For DOWN position: rising BTC = positive (dangerous)
    """
    if len(btc_price_history) < 2:
        return 0.0

    oldest_ts, oldest_price = btc_price_history[0]
    newest_ts, newest_price = btc_price_history[-1]

    if oldest_price == 0:
        return 0.0

    # Fractional change: (new - old) / old
    price_change = (newest_price - oldest_price) / oldest_price

    # For UP: falling price is bad, so negate (falling = negative change -> positive danger)
    # For DOWN: rising price is bad, so keep as-is (rising = positive change -> positive danger)
    if bet_side == "UP":
        return -price_change
    else:
        return price_change
```

Why deque import: Already imported from collections at module level (line 7).
Why near 99c functions: Logical grouping, same concern.
  </action>
  <verify>
Run `grep -n "DANGER_THRESHOLD\|DANGER_WEIGHT" trading_bot_smart.py` shows 6 constant definitions.
Run `grep -n "def get_price_velocity" trading_bot_smart.py` shows the function exists.
  </verify>
  <done>
- DANGER_THRESHOLD = 0.40 constant exists
- 5 DANGER_WEIGHT_* constants exist with specified values
- get_price_velocity() function exists and handles empty history gracefully
  </done>
</task>

<task type="auto">
  <name>Task 2: Create calculate_danger_score() function</name>
  <files>trading_bot_smart.py</files>
  <action>
Add `calculate_danger_score()` function immediately after `get_price_velocity()`:

```python
def calculate_danger_score(
    current_confidence: float,
    peak_confidence: float,
    our_imbalance: float,
    btc_price_history: deque,
    opponent_ask: float,
    time_remaining: float,
    bet_side: str
) -> dict:
    """
    Calculate danger score for 99c capture position.

    Formula:
    danger_score = (
        3.0 * (peak_confidence - current_confidence) +      # Confidence drop
        0.4 * max(-our_imbalance - 0.5, 0) +                # Order book selling pressure
        2.0 * max(price_velocity_against_us, 0) +           # BTC moving against us
        0.5 * max(opponent_ask - 0.20, 0) +                 # Opponent strength
        0.3 * max(1 - ttl/60, 0)                            # Time decay in final 60s
    )

    Returns dict with 'score' and individual signal components for logging.
    """
    # Signal 1: Confidence drop from peak (always >= 0)
    confidence_drop = max(peak_confidence - current_confidence, 0)
    conf_component = DANGER_WEIGHT_CONFIDENCE * confidence_drop

    # Signal 2: Order book imbalance against us
    # Negative imbalance = selling pressure. Only count if heavily negative (< -0.5)
    imb_signal = max(-our_imbalance - 0.5, 0)
    imb_component = DANGER_WEIGHT_IMBALANCE * imb_signal

    # Signal 3: BTC price velocity against our position
    velocity = get_price_velocity(btc_price_history, bet_side)
    velocity_component = DANGER_WEIGHT_VELOCITY * max(velocity, 0)

    # Signal 4: Opponent ask strength (only counts if > 20c)
    opp_signal = max(opponent_ask - 0.20, 0)
    opp_component = DANGER_WEIGHT_OPPONENT * opp_signal

    # Signal 5: Time decay in final 60 seconds (0 outside, ramps 0->1 as ttl goes 60->0)
    time_signal = max(1 - time_remaining / 60, 0) if time_remaining < 60 else 0
    time_component = DANGER_WEIGHT_TIME * time_signal

    # Total danger score (not capped - values > 1.0 mean "very dangerous")
    total = conf_component + imb_component + velocity_component + opp_component + time_component

    return {
        'score': total,
        'confidence_drop': confidence_drop,
        'confidence_component': conf_component,
        'imbalance': our_imbalance,
        'imbalance_component': imb_component,
        'velocity': velocity,
        'velocity_component': velocity_component,
        'opponent_ask': opponent_ask,
        'opponent_component': opp_component,
        'time_remaining': time_remaining,
        'time_component': time_component,
    }
```

Why return dict: Enables future logging of individual signal values (Phase 4).
Why not cap at 1.0: Values > 1.0 mean "very dangerous" which is useful information.
Why max(x, 0): Each signal should only contribute positively to danger (not reduce it).
  </action>
  <verify>
Run `grep -n "def calculate_danger_score" trading_bot_smart.py` shows the function exists.
Run `python3 -c "exec(open('trading_bot_smart.py').read())"` completes without syntax errors.
  </verify>
  <done>
- calculate_danger_score() function exists with correct signature
- Function returns dict with 'score' key and all component values
- All 5 signals implemented with correct formulas from REQUIREMENTS.md
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate danger scoring into main loop</name>
  <files>trading_bot_smart.py</files>
  <action>
Find the location in the main loop where `check_99c_capture_hedge()` is called (around line 2389-2391). The existing code is:

```python
if window_state.get('capture_99c_fill_notified') and not window_state.get('capture_99c_hedged'):
    check_99c_capture_hedge(books, remaining_secs)
```

Modify to calculate danger score BEFORE the hedge check:

```python
if window_state.get('capture_99c_fill_notified') and not window_state.get('capture_99c_hedged'):
    # Calculate danger score from 5 signals
    bet_side = window_state.get('capture_99c_side')

    # Get current confidence (same calculation as original entry)
    if bet_side == "UP":
        current_ask = float(books['up_asks'][0]['price']) if books.get('up_asks') else 0
    else:
        current_ask = float(books['down_asks'][0]['price']) if books.get('down_asks') else 0
    current_confidence, _ = calculate_99c_confidence(current_ask, remaining_secs)

    # Get order book imbalance for our side
    our_imbalance = 0.0
    if ORDERBOOK_ANALYZER_AVAILABLE:
        ob_result = orderbook_analyzer.analyze(
            books.get('up_bids', []), books.get('up_asks', []),
            books.get('down_bids', []), books.get('down_asks', [])
        )
        our_imbalance = ob_result['up_imbalance'] if bet_side == "UP" else ob_result['down_imbalance']

    # Get opponent ask price
    if bet_side == "UP":
        opponent_asks = books.get('down_asks', [])
    else:
        opponent_asks = books.get('up_asks', [])
    opponent_ask = float(opponent_asks[0]['price']) if opponent_asks else 0.50

    # Calculate danger score
    danger_result = calculate_danger_score(
        current_confidence=current_confidence,
        peak_confidence=window_state.get('capture_99c_peak_confidence', 0),
        our_imbalance=our_imbalance,
        btc_price_history=btc_price_history,
        opponent_ask=opponent_ask,
        time_remaining=remaining_secs,
        bet_side=bet_side
    )
    window_state['danger_score'] = danger_result['score']

    # Existing hedge check (will use danger_score in Phase 3)
    check_99c_capture_hedge(books, remaining_secs)
```

Why calculate before hedge check: Danger score must be available for hedge decision.
Why use ORDERBOOK_ANALYZER_AVAILABLE check: May be disabled in config, default to 0 (neutral).
Why 0.50 default for opponent_ask: Neutral value if no asks available.
  </action>
  <verify>
Run `grep -n "danger_result = calculate_danger_score" trading_bot_smart.py` shows integration exists.
Run `grep -n "window_state\['danger_score'\] = danger_result" trading_bot_smart.py` confirms storage.
Run `python3 -c "exec(open('trading_bot_smart.py').read())"` completes without syntax errors.
  </verify>
  <done>
- Main loop calls calculate_danger_score() when holding 99c position
- All 5 input signals gathered correctly (confidence, imbalance, velocity, opponent, time)
- Result stored in window_state['danger_score']
- Graceful defaults when data unavailable (imbalance=0, opponent=0.50)
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Syntax check:** `python3 -c "exec(open('trading_bot_smart.py').read())"` succeeds
2. **Constants exist:** `grep "DANGER_THRESHOLD\|DANGER_WEIGHT" trading_bot_smart.py` shows 6 lines
3. **Functions exist:** `grep "def get_price_velocity\|def calculate_danger_score" trading_bot_smart.py` shows 2 lines
4. **Integration exists:** `grep "danger_result = calculate_danger_score" trading_bot_smart.py` shows 1 line
5. **Storage exists:** `grep "window_state\['danger_score'\] = danger_result" trading_bot_smart.py` shows 1 line
</verification>

<success_criteria>
- SCORE-01: System calculates danger score every tick when 99c position is held
- SCORE-02: Score incorporates confidence drop from peak (weight: 3.0)
- SCORE-03: Score incorporates order book imbalance on our side (weight: 0.4)
- SCORE-04: Score incorporates 5-second price velocity (weight: 2.0)
- SCORE-05: Score incorporates opponent ask price (weight: 0.5)
- SCORE-06: Score incorporates time decay in final 60 seconds (weight: 0.3)
- CFG-01: Danger threshold configurable via DANGER_THRESHOLD constant (default 0.40)
- CFG-02: Individual signal weights configurable via DANGER_WEIGHT_* constants
</success_criteria>

<output>
After completion, create `.planning/phases/02-danger-scoring-engine/02-01-SUMMARY.md`
</output>
