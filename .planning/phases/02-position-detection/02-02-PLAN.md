---
phase: 02-position-detection
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified: [performance_tracker.py]
autonomous: true

must_haves:
  truths:
    - "Bot determines winning side after window closes"
    - "Bot grades ARB trades as PAIRED, LOPSIDED, or BAIL"
    - "Bot grades 99c captures as WIN or LOSS"
    - "Bot calculates accurate P/L for ARB trades"
    - "Bot calculates accurate P/L for 99c captures"
    - "Graded window output shows actual trade results"
  artifacts:
    - path: "performance_tracker.py"
      provides: "Market resolution and outcome grading"
      exports: ["get_market_resolution", "classify_arb_result", "grade_arb_trade", "grade_99c_trade"]
  key_links:
    - from: "performance_tracker.py"
      to: "clob.polymarket.com"
      via: "HTTP GET in get_market_resolution"
      pattern: "clob\\.polymarket\\.com/markets"
    - from: "performance_tracker.py:grade_window()"
      to: "grade_arb_trade"
      via: "function call when arb_entry present"
      pattern: "grade_arb_trade.*window_state"
    - from: "performance_tracker.py:grade_window()"
      to: "grade_99c_trade"
      via: "function call when capture_entry present"
      pattern: "grade_99c_trade.*window_state"
---

<objective>
Add market resolution checking and outcome grading with P/L calculation.

Purpose: Enable the bot to grade trade outcomes and calculate profit/loss after each window closes.
Output: Graded window output shows actual trade results and P/L (not placeholders).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/02-position-detection/02-RESEARCH.md
@.planning/phases/02-position-detection/02-01-SUMMARY.md (if exists, for position detection patterns)
@performance_tracker.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add market resolution function</name>
  <files>performance_tracker.py</files>
  <action>
Add `get_market_resolution(condition_id)` function based on research pattern (lines 156-178):

```python
def get_market_resolution(condition_id):
    """Check if market resolved and which side won.

    Returns:
        {'resolved': True, 'winner': 'UP' or 'DOWN', 'winner_token': token_id}
        or {'resolved': False} if not yet resolved
    """
    try:
        url = f"https://clob.polymarket.com/markets/{condition_id}"
        resp = http_session.get(url, timeout=5)
        if resp.status_code == 200:
            data = resp.json()
            tokens = data.get('tokens', [])
            for token in tokens:
                if token.get('winner') == True:
                    outcome = token.get('outcome', '').upper()
                    # Normalize: "Up" -> "UP", "Down" -> "DOWN"
                    if 'UP' in outcome:
                        winner = 'UP'
                    elif 'DOWN' in outcome:
                        winner = 'DOWN'
                    else:
                        winner = outcome
                    return {
                        'resolved': True,
                        'winner': winner,
                        'winner_token': token.get('token_id')
                    }
            return {'resolved': False}
    except Exception as e:
        print(f"[WARN] Resolution check failed: {e}")
    return {'resolved': False}
```

Also add helper to get condition_id from market data:
```python
def get_condition_id(market):
    """Extract condition ID from market data."""
    return market.get('markets', [{}])[0].get('conditionId')
```
  </action>
  <verify>
Run: `python3 -c "import performance_tracker; print(performance_tracker.get_market_resolution.__doc__)"` should show docstring.
Run: `python3 -c "import performance_tracker; print(performance_tracker.get_condition_id.__doc__)"` should show docstring.
  </verify>
  <done>
get_market_resolution() and get_condition_id() functions exist and are callable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add ARB and 99c grading functions with P/L</name>
  <files>performance_tracker.py</files>
  <action>
Add three functions for grading and P/L calculation:

1. `classify_arb_result(up_shares, down_shares)`:
   - If `abs(up_shares - down_shares) < 0.5`: return `'PAIRED'`
   - If `up_shares == 0 or down_shares == 0`: return `'BAIL'`
   - Otherwise: return `'LOPSIDED'`
   - Pattern from research lines 359-377

2. `grade_arb_trade(window_state, winning_side)`:
   - Get `arb_entry = window_state.get('arb_entry', {})`
   - Calculate result using `classify_arb_result()`
   - Calculate P/L:
     - For PAIRED: `min_shares * 1.00` payout minus cost
     - Estimate costs: use 0.42 for cheap side, 0.57 for expensive side (approximation)
     - If winning_side == 'UP': up_cost = 0.57, down_cost = 0.42 (DOWN was cheaper = bet on UP)
     - If winning_side == 'DOWN': up_cost = 0.42, down_cost = 0.57 (UP was cheaper = bet on DOWN)
     - total_cost = up_shares * up_cost + down_shares * down_cost
     - payout = min(up_shares, down_shares) * 1.00
     - pnl = payout - total_cost
   - Return `{'result': result, 'pnl': pnl}`

   Note: Using estimated costs for v1. Phase 2 research says this is acceptable.

3. `grade_99c_trade(window_state, winning_side)`:
   - Get `capture_entry = window_state.get('capture_entry', {})`
   - side = capture_entry['side'], shares = capture_entry['shares']
   - cost = shares * 0.99 (99c capture always at 99c)
   - If side == winning_side: payout = shares * 1.00, pnl = payout - cost, result = 'WIN'
   - Else: payout = 0, pnl = -cost, result = 'LOSS'
   - Return `{'result': result, 'pnl': pnl}`
  </action>
  <verify>
Run simple test:
```python
python3 -c "
from performance_tracker import classify_arb_result, grade_arb_trade, grade_99c_trade
print('PAIRED:', classify_arb_result(5, 5))
print('LOPSIDED:', classify_arb_result(5, 3))
print('BAIL:', classify_arb_result(5, 0))

# Test ARB grading
ws = {'arb_entry': {'up_shares': 5, 'down_shares': 5}}
print('ARB grade:', grade_arb_trade(ws, 'UP'))

# Test 99c grading
ws = {'capture_entry': {'side': 'UP', 'shares': 5}}
print('99c WIN:', grade_99c_trade(ws, 'UP'))
print('99c LOSS:', grade_99c_trade(ws, 'DOWN'))
"
```

Expected: PAIRED, LOPSIDED, BAIL, then P/L numbers.
  </verify>
  <done>
classify_arb_result, grade_arb_trade, and grade_99c_trade functions return correct results and P/L values.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire grading into grade_window</name>
  <files>performance_tracker.py</files>
  <action>
Update `grade_window(state)` to use actual grading functions:

1. Add market parameter: Change signature to `grade_window(state, market)` (or access cached_market globally).

2. Get market resolution:
   ```python
   condition_id = get_condition_id(market)
   if not condition_id:
       print("[WARN] No condition ID, cannot grade")
       return

   resolution = get_market_resolution(condition_id)
   if not resolution.get('resolved'):
       print("[WARN] Market not yet resolved, skipping grade")
       return

   winning_side = resolution['winner']
   state['outcome'] = winning_side
   ```

3. Grade ARB trade if present:
   ```python
   if state.get('arb_entry'):
       arb_grade = grade_arb_trade(state, winning_side)
       state['arb_result'] = arb_grade['result']
       state['arb_pnl'] = arb_grade['pnl']
   ```

4. Grade 99c capture if present:
   ```python
   if state.get('capture_entry'):
       capture_grade = grade_99c_trade(state, winning_side)
       state['capture_result'] = capture_grade['result']
       state['capture_pnl'] = capture_grade['pnl']
   ```

5. Update the graded row output to show:
   - Outcome (UP or DOWN won)
   - ARB result (PAIRED/LOPSIDED/BAIL or -)
   - 99c result (WIN/LOSS or -)
   - P/L values (actual numbers, not placeholders)

6. Update main() to pass market to grade_window:
   - Find the two places where `grade_window(window_state)` is called
   - Change to `grade_window(window_state, cached_market)`
  </action>
  <verify>
Run the tracker until a window closes (or wait ~15 min). The graded output should show:
- Outcome: UP or DOWN
- Actual result classifications (not None)
- Actual P/L values (not $0.00 placeholders if trades occurred)

If no trades, should show "-" for entries and $0.00 for P/L (which is correct).
  </verify>
  <done>
grade_window() calls resolution API and grading functions. Output shows actual trade results and P/L.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. Bot runs without errors
2. At window close, resolution API is called
3. ARB trades graded as PAIRED/LOPSIDED/BAIL with P/L
4. 99c captures graded as WIN/LOSS with P/L
5. Graded window output shows actual results (not placeholders)
</verification>

<success_criteria>
- POS-02 COMPLETE: Detects ARB completion status (paired, lopsided, bail)
- POS-04 COMPLETE: Detects 99c capture outcomes (win/loss)
- POS-05 COMPLETE: Calculates P/L for each trade type
- Phase 2 100% complete: All 5 requirements satisfied
- Ready for Phase 3 (Google Sheet Dashboard)
</success_criteria>

<output>
After completion, create `.planning/phases/02-position-detection/02-02-SUMMARY.md`
</output>
