---
phase: 01-core-bot-infrastructure
plan: 03
type: execute
wave: 3
depends_on:
  - "01-02"
files_modified:
  - performance_tracker.py
autonomous: true

must_haves:
  truths:
    - "Bot detects when one window ends and another begins"
    - "Bot outputs a graded row to console at window close"
    - "Graded row contains placeholder data (actual data in Phase 2)"
  artifacts:
    - path: "performance_tracker.py"
      provides: "Window transition detection and grading skeleton"
      exports: ["grade_window", "reset_window_state"]
  key_links:
    - from: "main loop"
      to: "grade_window"
      via: "window transition trigger"
      pattern: "if slug != last_slug.*grade_window"
    - from: "grade_window"
      to: "console"
      via: "print"
      pattern: "WINDOW GRADED"
---

<objective>
Add window transition detection and graded row output skeleton.

Purpose: When a window closes, the bot should output a summary row (skeleton now, real data in Phase 2).
Output: Bot prints graded row with placeholder data when each window ends.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-core-bot-infrastructure/01-RESEARCH.md
@.planning/phases/01-core-bot-infrastructure/01-01-SUMMARY.md
@.planning/phases/01-core-bot-infrastructure/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add window state management</name>
  <files>performance_tracker.py</files>
  <action>
Add window state management functions after the window detection functions:

1. **reset_window_state(slug)** - Initialize fresh state for a new window:
   ```python
   def reset_window_state(slug):
       """Initialize fresh window state for tracking."""
       return {
           'slug': slug,
           'started_at': datetime.now(PST),
           # Position tracking (populated in Phase 2)
           'arb_entry': None,       # {'up_shares': X, 'down_shares': X, 'cost': X}
           'arb_result': None,      # 'PAIRED', 'BAIL', 'LOPSIDED'
           'arb_pnl': 0.0,
           'capture_entry': None,   # {'side': 'UP'/'DOWN', 'shares': X, 'cost': X}
           'capture_result': None,  # 'WIN', 'LOSS'
           'capture_pnl': 0.0,
           # Metadata
           'window_end_price': None,
           'outcome': None,         # 'UP' or 'DOWN'
       }
   ```

2. **Add global window_state** at module level (after constants):
   ```python
   # Global window state
   window_state = None
   ```

This prepares the data structure for Phase 2's position detection.
  </action>
  <verify>
`python3 -c "import performance_tracker; print(performance_tracker.reset_window_state('test'))"`
Should print dict with all keys.
  </verify>
  <done>
Window state structure defined with all required fields.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add grade_window function and transition handling</name>
  <files>performance_tracker.py</files>
  <action>
1. **Add grade_window(state)** function after reset_window_state:
   ```python
   def grade_window(state):
       """Grade a completed window and output summary row.

       This is a skeleton that outputs placeholder data.
       Phase 2 will populate actual position and P/L data.
       """
       if not state:
           return

       slug = state.get('slug', 'unknown')
       started = state.get('started_at', datetime.now(PST))

       # Extract window time from slug (e.g., btc-updown-15m-1737417600)
       try:
           window_ts = int(slug.split('-')[-1])
           window_time = datetime.fromtimestamp(window_ts, tz=PST).strftime('%H:%M')
       except:
           window_time = started.strftime('%H:%M')

       # Placeholder data (Phase 2 will populate)
       arb_entry = state.get('arb_entry')
       arb_result = state.get('arb_result', '-')
       arb_pnl = state.get('arb_pnl', 0)

       capture_entry = state.get('capture_entry')
       capture_result = state.get('capture_result', '-')
       capture_pnl = state.get('capture_pnl', 0)

       total_pnl = arb_pnl + capture_pnl

       # Format row
       print(f"\n{'='*60}")
       print(f"WINDOW GRADED: {slug}")
       print(f"{'='*60}")
       print(f"  Time:        {window_time}")
       print(f"  ARB Entry:   {'Yes' if arb_entry else '-'}")
       print(f"  ARB Result:  {arb_result}")
       print(f"  ARB P/L:     ${arb_pnl:+.2f}")
       print(f"  99c Entry:   {'Yes' if capture_entry else '-'}")
       print(f"  99c Result:  {capture_result}")
       print(f"  99c P/L:     ${capture_pnl:+.2f}")
       print(f"  -----------")
       print(f"  TOTAL P/L:   ${total_pnl:+.2f}")
       print(f"{'='*60}\n")
   ```

2. **Update main() loop** to use window state and grade on transition:
   ```python
   def main():
       global window_state
       print("Performance Tracker starting main loop...")

       cached_market = None
       last_slug = None

       while True:
           cycle_start = time.time()

           try:
               # Get current window
               slug, window_start = get_current_slug()

               # Detect window transition
               if slug != last_slug:
                   # Grade completed window (if exists)
                   if last_slug is not None and window_state is not None:
                       grade_window(window_state)

                   # Start fresh window
                   window_state = reset_window_state(slug)
                   cached_market = None
                   last_slug = slug

                   print(f"\n{'='*50}")
                   print(f"NEW WINDOW: {slug}")
                   print(f"{'='*50}")

               # Fetch market data (cache per window)
               if not cached_market:
                   cached_market = get_market_data(slug)
                   if not cached_market:
                       print(f"[{datetime.now(PST).strftime('%H:%M:%S')}] Waiting for market data...")
                       time.sleep(2)
                       continue

               # Calculate time remaining
               time_str, remaining_secs = get_time_remaining(cached_market)

               if remaining_secs < 0:
                   print(f"[{datetime.now(PST).strftime('%H:%M:%S')}] Window ended, waiting for next...")
                   time.sleep(2)
                   continue

               # Display status line
               print(f"[{datetime.now(PST).strftime('%H:%M:%S')}] T-{remaining_secs:3d}s | {slug}")

               # Maintain 1-second loop
               elapsed = time.time() - cycle_start
               time.sleep(max(0, 1 - elapsed))

           except Exception as e:
               print(f"ERROR: {e}")
               import traceback
               traceback.print_exc()
               time.sleep(1)

   if __name__ == "__main__":
       main()
   ```

Key changes:
- Global window_state for tracking across loop iterations
- grade_window() called when slug changes (window transition)
- reset_window_state() creates fresh state for new window
  </action>
  <verify>
Run: `python3 performance_tracker.py`
- Let it run for at least one window transition (or wait until minute :00, :15, :30, :45)
- Should see "WINDOW GRADED" output with placeholder data when window ends
- New window should immediately start tracking

Alternative quick test: Manually set a fake last_slug in the code to force immediate transition.
  </verify>
  <done>
Window transitions trigger grade_window() with skeleton output.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add window end detection for immediate grading</name>
  <files>performance_tracker.py</files>
  <action>
The current design waits for slug to change, but that can take 1-2 seconds after window actually ends. Add a more responsive approach:

1. **Add GRADE_DELAY_SECONDS constant**:
   ```python
   GRADE_DELAY_SECONDS = 3  # Wait a few seconds after window ends before grading
   ```

2. **Update main loop** to grade immediately when remaining_secs hits 0:
   In the main loop, after calculating remaining_secs:
   ```python
   # Check if window just ended
   if remaining_secs <= 0 and window_state and not window_state.get('graded'):
       # Wait a moment for settlement
       time.sleep(GRADE_DELAY_SECONDS)

       # Grade the window
       grade_window(window_state)
       window_state['graded'] = True

       # Continue to wait for new window
       continue
   ```

3. **Update reset_window_state** to include 'graded' flag:
   ```python
   'graded': False,
   ```

This ensures we grade as soon as window ends rather than waiting for slug change.
  </action>
  <verify>
Run: `python3 performance_tracker.py`
- Watch the countdown approach 0
- Should see "WINDOW GRADED" appear within ~3 seconds of T-0
- Should not grade twice (graded flag prevents)
  </verify>
  <done>
Windows are graded immediately at close, not delayed until slug changes.
  </done>
</task>

</tasks>

<verification>
1. Bot runs continuously and tracks window state
2. When window countdown hits 0, graded row appears within a few seconds
3. Graded row shows all columns (Time, ARB Entry/Result/P/L, 99c Entry/Result/P/L, Total)
4. All values are placeholders (- or $0.00) since Phase 2 adds position detection
5. New window starts immediately after grading
6. No double-grading of same window
</verification>

<success_criteria>
- Window transitions detected reliably
- grade_window() outputs formatted summary to console
- Skeleton ready for Phase 2 to populate actual data
- CORE-03 (window boundary detection) complete
- CORE-04 (graded row output) complete (skeleton)
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-bot-infrastructure/01-03-SUMMARY.md`
</output>
