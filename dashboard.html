<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Polybot Terminal</title>
  <link rel="icon" type="image/png" href="data:image/png;base64,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">
  <link rel="apple-touch-icon" href="data:image/png;base64,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">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4/dist/chart.umd.min.js"></script>
  <style>
    :root {
      --bg-primary: #0a0a0b;
      --bg-secondary: #111113;
      --bg-card: rgba(17, 17, 19, 0.8);
      --border-subtle: rgba(255, 255, 255, 0.06);
      --border-glow: rgba(52, 211, 153, 0.3);
      --text-primary: #f4f4f5;
      --text-secondary: #71717a;
      --text-muted: #52525b;
      --green-primary: #34d399;
      --green-glow: rgba(52, 211, 153, 0.15);
      --green-dark: #059669;
      --red-primary: #f87171;
      --red-glow: rgba(248, 113, 113, 0.15);
      --yellow-primary: #fbbf24;
      --gold-accent: #d4af37;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Outfit', -apple-system, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      overflow-x: hidden;
    }

    /* Animated gradient background */
    .bg-mesh {
      position: fixed;
      inset: 0;
      background:
        radial-gradient(ellipse 80% 50% at 20% -20%, rgba(52, 211, 153, 0.08), transparent),
        radial-gradient(ellipse 60% 40% at 80% 100%, rgba(52, 211, 153, 0.05), transparent),
        var(--bg-primary);
      z-index: -1;
    }

    /* Subtle noise texture */
    .noise {
      position: fixed;
      inset: 0;
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
      opacity: 0.02;
      pointer-events: none;
      z-index: -1;
    }

    .container {
      max-width: 420px;
      margin: 0 auto;
      padding: 20px 16px 32px;
      position: relative;
    }

    /* Header */
    .header {
      margin-bottom: 24px;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 4px;
    }

    .logo-icon {
      width: 32px;
      height: 32px;
      background: linear-gradient(135deg, var(--green-primary), var(--green-dark));
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      box-shadow: 0 4px 12px rgba(52, 211, 153, 0.3);
    }

    .logo-text {
      font-family: 'JetBrains Mono', monospace;
      font-size: 20px;
      font-weight: 700;
      letter-spacing: -0.5px;
      background: linear-gradient(135deg, var(--text-primary) 0%, var(--text-secondary) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .date {
      font-size: 13px;
      color: var(--text-muted);
      font-weight: 400;
      padding-left: 42px;
    }

    /* Status indicator */
    .status-dot {
      display: inline-block;
      width: 6px;
      height: 6px;
      background: var(--green-primary);
      border-radius: 50%;
      margin-right: 6px;
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; box-shadow: 0 0 0 0 rgba(52, 211, 153, 0.4); }
      50% { opacity: 0.8; box-shadow: 0 0 0 4px rgba(52, 211, 153, 0); }
    }

    /* Cards */
    .card {
      background: var(--bg-card);
      border: 1px solid var(--border-subtle);
      border-radius: 16px;
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      overflow: hidden;
      position: relative;
    }

    .card::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 16px;
      padding: 1px;
      background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0));
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
      pointer-events: none;
    }

    /* Summary Grid */
    .summary-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 20px;
    }

    .stat-card {
      padding: 20px 16px;
      text-align: center;
    }

    .stat-card.primary {
      background: linear-gradient(135deg, rgba(52, 211, 153, 0.08), rgba(52, 211, 153, 0.02));
      border-color: var(--border-glow);
    }

    .stat-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 32px;
      font-weight: 700;
      letter-spacing: -1px;
      line-height: 1;
      margin-bottom: 6px;
    }

    .stat-value.positive { color: var(--green-primary); }
    .stat-value.negative { color: var(--red-primary); }
    .stat-value.neutral { color: var(--text-muted); }

    .stat-label {
      font-size: 11px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    .stat-detail {
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .stat-roi {
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
      font-weight: 600;
      margin-top: 6px;
    }

    .stat-roi.positive { color: var(--green-primary); }
    .stat-roi.negative { color: var(--red-primary); }

    /* Section Headers */
    .section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
      padding: 0 4px;
    }

    .section-title {
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: var(--text-secondary);
    }

    .section-badge {
      font-family: 'JetBrains Mono', monospace;
      font-size: 10px;
      font-weight: 500;
      color: var(--text-muted);
      background: rgba(255,255,255,0.05);
      padding: 3px 8px;
      border-radius: 4px;
    }

    /* Trade List */
    .trades-card {
      padding: 4px;
      margin-bottom: 20px;
    }

    .date-separator {
      font-size: 11px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      padding: 12px 12px 6px;
      margin-top: 8px;
      border-top: 1px solid rgba(255,255,255,0.06);
    }

    .date-separator:first-child {
      border-top: none;
      margin-top: 0;
      padding-top: 6px;
    }

    .trade-item {
      display: flex;
      align-items: center;
      padding: 12px;
      border-radius: 10px;
      transition: background 0.2s ease;
    }

    .trade-item:hover {
      background: rgba(255,255,255,0.02);
    }

    .trade-status {
      width: 28px;
      height: 28px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      margin-right: 12px;
      flex-shrink: 0;
    }

    .trade-status.win {
      background: var(--green-glow);
      color: var(--green-primary);
    }

    .trade-status.loss {
      background: var(--red-glow);
      color: var(--red-primary);
    }

    .trade-status.pending {
      background: rgba(251, 191, 36, 0.1);
      color: var(--yellow-primary);
    }

    .trade-status.exit {
      background: rgba(251, 146, 60, 0.15);
      color: #fb923c;
    }

    .trade-status.profit-lock {
      background: var(--green-glow);
      color: var(--green-primary);
    }

    .trade-pnl.exit { color: #fb923c; }

    .trade-info {
      flex: 1;
      min-width: 0;
    }

    .trade-pair {
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 2px;
    }

    .trade-detail {
      font-size: 11px;
      color: var(--text-muted);
      margin-bottom: 1px;
    }

    .trade-detail .roi { font-weight: 500; }
    .trade-detail .roi.positive { color: var(--green-primary); }
    .trade-detail .roi.negative { color: var(--red-primary); }

    .trade-meta {
      font-size: 11px;
      color: var(--text-muted);
    }

    .trade-pnl {
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
      font-weight: 600;
      text-align: right;
      margin-left: 12px;
    }

    .trade-pnl.positive { color: var(--green-primary); }
    .trade-pnl.negative { color: var(--red-primary); }
    .trade-pnl.pending { color: var(--yellow-primary); font-size: 11px; }

    /* Window-grouped trades */
    .window-group { margin-bottom: 2px; }
    .window-summary { cursor: pointer; user-select: none; }
    .window-summary:hover { background: rgba(255,255,255,0.04); }
    .window-summary .fill-count {
      font-size: 10px;
      color: var(--text-muted);
      opacity: 0.7;
    }
    .window-summary .chevron {
      font-size: 10px;
      color: var(--text-muted);
      transition: transform 0.15s ease;
      display: inline-block;
      margin-right: 2px;
    }
    .window-summary.expanded .chevron { transform: rotate(90deg); }
    .window-fills {
      display: none;
      padding-left: 40px;
    }
    .window-fills.open { display: block; }
    .window-fills .trade-item {
      padding: 6px 12px;
      opacity: 0.7;
    }
    .window-fills .trade-pair { font-size: 12px; }
    .window-fills .trade-pnl { font-size: 12px; }
    .window-fills .trade-detail { font-size: 10px; }
    .window-fills .trade-meta { display: none; }
    .window-fills .trade-status {
      width: 20px;
      height: 20px;
      font-size: 11px;
      margin-right: 8px;
    }

    /* History */
    /* Fill Rate Analytics */
    .fillrate-grid {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 12px;
      text-align: center;
    }
    .fillrate-stat {
      padding: 8px;
      background: rgba(255,255,255,0.02);
      border-radius: 8px;
    }
    .fillrate-hours {
      display: flex;
      gap: 3px;
      align-items: flex-end;
      height: 48px;
    }
    .fillrate-bar {
      flex: 1;
      border-radius: 3px 3px 0 0;
      position: relative;
      min-width: 0;
      cursor: default;
    }
    .fillrate-bar-label {
      position: absolute;
      bottom: -16px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 9px;
      color: var(--text-muted);
      white-space: nowrap;
    }
    .fillrate-table {
      max-height: 320px;
      overflow-y: auto;
    }
    .fillrate-row {
      display: grid;
      grid-template-columns: 90px 40px 50px 50px 60px;
      gap: 8px;
      align-items: center;
      padding: 5px 4px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      color: var(--text-secondary);
      border-bottom: 1px solid var(--border-subtle);
    }
    .fillrate-row.header {
      color: var(--text-muted);
      font-size: 10px;
      text-transform: uppercase;
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    .fillrate-pct { text-align: right; }
    .fillrate-pct.green { color: var(--green-primary); }
    .fillrate-pct.orange { color: var(--yellow-primary); }
    .fillrate-pct.white { color: var(--text-primary); }

    .fill-badge {
      font-family: 'JetBrains Mono', monospace;
      font-size: 10px;
      padding: 1px 5px;
      border-radius: 4px;
      background: rgba(255,255,255,0.06);
      color: var(--text-secondary);
      vertical-align: middle;
    }
    .fill-badge.green { color: var(--green-primary); background: var(--green-glow); }
    .fill-badge.orange { color: var(--yellow-primary); background: rgba(251, 191, 36, 0.12); }

    .history-card {
      padding: 4px;
    }

    .history-item {
      display: grid;
      grid-template-columns: 1fr auto auto auto;
      gap: 12px;
      align-items: center;
      padding: 14px 12px;
      border-radius: 10px;
      transition: background 0.2s ease;
    }

    .history-item:hover {
      background: rgba(255,255,255,0.02);
    }

    .history-date {
      font-size: 13px;
      font-weight: 500;
      color: var(--text-primary);
    }

    .history-pnl {
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
      font-weight: 600;
    }

    .history-pnl.positive { color: var(--green-primary); }
    .history-pnl.negative { color: var(--red-primary); }

    .history-record {
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .history-roi {
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      font-weight: 500;
      min-width: 50px;
      text-align: right;
    }

    .history-roi.positive { color: var(--green-primary); }
    .history-roi.negative { color: var(--red-primary); }

    /* Footer */
    .footer {
      text-align: center;
      margin-top: 24px;
      padding-top: 16px;
      border-top: 1px solid var(--border-subtle);
    }

    .footer-text {
      font-size: 11px;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    /* Error Banner */
    .error-banner {
      background: rgba(248, 113, 113, 0.1);
      border: 1px solid rgba(248, 113, 113, 0.2);
      border-radius: 10px;
      padding: 12px 16px;
      margin-bottom: 16px;
      font-size: 13px;
      color: var(--red-primary);
      display: none;
    }

    .error-banner.visible {
      display: block;
    }

    /* Loading state */
    .loading {
      color: var(--text-muted);
      font-size: 13px;
      text-align: center;
      padding: 20px;
    }

    /* Empty state */
    .empty-state {
      color: var(--text-muted);
      font-size: 13px;
      text-align: center;
      padding: 24px;
    }

    /* Animations */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(8px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .animate-in {
      animation: fadeIn 0.4s ease-out forwards;
    }

    .delay-1 { animation-delay: 0.1s; opacity: 0; }
    .delay-2 { animation-delay: 0.2s; opacity: 0; }
    .delay-3 { animation-delay: 0.3s; opacity: 0; }
    .delay-4 { animation-delay: 0.4s; opacity: 0; }

    /* Tab bar */
    .tab-bar {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    .tab {
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      padding: 6px 16px;
      border-radius: 8px;
      border: 1px solid var(--border-subtle);
      background: transparent;
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.2s;
    }
    .tab.active {
      color: var(--green-primary);
      border-color: var(--green-primary);
      background: var(--green-glow);
    }
    .tab:hover:not(.active) {
      color: var(--text-secondary);
      border-color: var(--text-secondary);
    }

    /* Live Status Panel */
    .live-panel { padding: 16px; }
    .live-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }
    .live-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      font-weight: 700;
      letter-spacing: 0.5px;
    }
    .live-badge .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-muted);
    }
    .live-badge.sniper .dot, .live-badge.paired .dot {
      background: var(--green-primary);
      box-shadow: 0 0 8px var(--green-primary);
    }
    .live-badge.pairing .dot {
      background: var(--yellow-primary);
      box-shadow: 0 0 8px var(--yellow-primary);
    }
    .live-badge.imbal .dot {
      background: var(--red-primary);
      box-shadow: 0 0 8px var(--red-primary);
    }
    .live-header-right {
      display: flex;
      align-items: baseline;
      gap: 12px;
    }
    .live-ttl {
      font-family: 'JetBrains Mono', monospace;
      font-size: 20px;
      font-weight: 700;
    }
    .live-stale {
      font-family: 'JetBrains Mono', monospace;
      font-size: 10px;
      color: var(--green-primary);
    }
    .live-stale.warning { color: var(--yellow-primary); }
    .live-stale.stale { color: var(--red-primary); }

    .live-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 12px;
    }
    .live-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--text-muted);
      margin-bottom: 2px;
    }
    .live-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 16px;
      font-weight: 600;
      color: var(--text-primary);
    }
    .live-reason {
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      color: var(--text-secondary);
      padding-top: 8px;
      border-top: 1px solid var(--border-subtle);
    }

    /* Event Feed */
    .event-feed {
      max-height: 320px;
      overflow-y: auto;
    }
    .event-item {
      display: flex;
      align-items: baseline;
      gap: 8px;
      padding: 6px 12px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      border-bottom: 1px solid var(--border-subtle);
    }
    .event-time {
      color: var(--text-muted);
      white-space: nowrap;
    }
    .event-icon { width: 14px; text-align: center; }
    .event-text { flex: 1; }
    .event-text.green { color: var(--green-primary); }
    .event-text.red { color: var(--red-primary); }
    .event-text.yellow { color: var(--yellow-primary); }
    .event-text.muted { color: var(--text-secondary); }

    /* Paper Trading */
    .paper-badge {
      display: inline-block;
      font-family: 'JetBrains Mono', monospace;
      font-size: 9px;
      font-weight: 700;
      letter-spacing: 1px;
      color: #a78bfa;
      background: rgba(167, 139, 250, 0.1);
      border: 1px solid rgba(167, 139, 250, 0.2);
      padding: 2px 6px;
      border-radius: 4px;
    }

    .stat-card.paper {
      background: linear-gradient(135deg, rgba(167, 139, 250, 0.08), rgba(167, 139, 250, 0.02));
      border-color: rgba(167, 139, 250, 0.3);
    }

    .trade-status.paper-exit {
      background: rgba(167, 139, 250, 0.1);
      color: #a78bfa;
    }
    .trade-pnl.paper-exit { color: #a78bfa; }

    /* Desktop layout */
    @media (min-width: 768px) {
      .container {
        max-width: 900px;
        padding: 24px 24px 32px;
      }
      .summary-grid {
        gap: 16px;
      }
      .main-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        align-items: start;
      }
      .main-grid > * {
        min-width: 0;
      }
    }
  </style>
</head>
<body>
  <div class="bg-mesh"></div>
  <div class="noise"></div>

  <div class="container">
    <!-- Header -->
    <header class="header animate-in">
      <div class="logo">
        <div class="logo-icon">âš¡</div>
        <span class="logo-text">POLYBOT</span>
      </div>
      <p class="date" id="date"><span class="status-dot"></span>Loading...</p>
      <p class="date" id="clock" style="font-size:12px; opacity:0.7;"></p>
    </header>

    <!-- Tab Bar -->
    <div class="tab-bar animate-in">
      <button class="tab active" data-tab="trades">Trades</button>
      <button class="tab" data-tab="90ctest">90c Test</button>
      <button class="tab" data-tab="paper">Paper</button>
      <button class="tab" data-tab="live">Live Status</button>
    </div>

    <!-- Trades View (existing dashboard) -->
    <div id="trades-view">

    <!-- Error Banner -->
    <div class="error-banner" id="error">
      <span id="errorMsg">Error loading data</span>
    </div>

    <!-- Summary Cards -->
    <div class="summary-grid animate-in delay-1">
      <div class="card stat-card primary">
        <div class="stat-label">Today's P&L</div>
        <div class="stat-value neutral" id="todayPnl">--</div>
      </div>
      <div class="card stat-card">
        <div class="stat-label">Win Rate</div>
        <div class="stat-value neutral" id="winRate">--</div>
        <div class="stat-detail" id="record">--</div>
        <div class="stat-roi" id="roi"></div>
      </div>
    </div>

    <!-- Fill Rate Analytics -->
    <div class="animate-in delay-1" id="fillRateSection" style="display:none; margin-bottom: 20px;">
      <div class="section-header">
        <span class="section-title">Fill Rate Analytics</span>
        <span class="section-badge" id="fillRateCount">0 fills</span>
      </div>
      <div class="card" style="padding: 16px;">
        <div class="fillrate-grid">
          <div class="fillrate-stat">
            <div class="stat-label">Avg Fill Rate</div>
            <div class="stat-value" id="avgFillRate" style="font-size:24px">--</div>
          </div>
          <div class="fillrate-stat">
            <div class="stat-label">UP Fills</div>
            <div class="stat-value" id="upFillRate" style="font-size:24px">--</div>
          </div>
          <div class="fillrate-stat">
            <div class="stat-label">DOWN Fills</div>
            <div class="stat-value" id="dnFillRate" style="font-size:24px">--</div>
          </div>
        </div>
        <div style="margin-top: 14px;">
          <div class="stat-label" style="margin-bottom: 8px;">Fill Rate by Hour (EST)</div>
          <div id="fillRateByHour" class="fillrate-hours"></div>
        </div>
        <div style="margin-top: 14px;">
          <div class="stat-label" style="margin-bottom: 8px;">Recent Fills</div>
          <div id="fillRateTable" class="fillrate-table"></div>
        </div>
      </div>
    </div>

    <div class="main-grid">
      <!-- Recent Trades -->
      <div class="animate-in delay-2">
        <div class="section-header">
          <span class="section-title">Today's Trades</span>
          <span class="section-badge" id="tradesToggle" style="cursor:pointer">SHOW ALL</span>
        </div>
        <div class="card trades-card" id="trades">
          <p class="loading">Loading trades...</p>
        </div>
      </div>

      <!-- Right column: Daily History + Balance Chart -->
      <div>
        <div class="animate-in delay-3">
          <div class="section-header">
            <span class="section-title">Daily History</span>
          </div>
          <div class="card history-card" id="history">
            <p class="loading">Loading history...</p>
          </div>
        </div>

        <div class="animate-in delay-4" style="margin-top: 20px;">
          <div class="section-header">
            <span class="section-title">Portfolio Balance</span>
          </div>
          <div class="card" id="balanceChartCard" style="padding: 1rem; display: none;">
            <canvas id="balanceCanvas" height="200"></canvas>
          </div>
        </div>
      </div>
    </div>
    </div><!-- /trades-view -->

    <!-- 90c Test View -->
    <div id="90ctest-view" style="display:none">
      <div class="summary-grid animate-in">
        <div class="stat-card">
          <div class="stat-label">P&L (90c)</div>
          <div id="test90cPnl" class="stat-value neutral">--</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">WIN RATE</div>
          <div id="test90cWinRate" class="stat-value neutral">--</div>
          <div id="test90cRecord" class="stat-detail">--</div>
          <div id="test90cRoi" class="stat-roi"></div>
        </div>
      </div>
      <div class="main-grid">
        <div>
          <div class="section-header">
            <span class="section-title">Today's Trades</span>
          </div>
          <div id="test90cTrades" class="card trades-card animate-in">
            <p class="empty-state">Loading 90c test trades...</p>
          </div>
        </div>
        <div>
          <div class="section-header">
            <span class="section-title">Daily History</span>
          </div>
          <div id="test90cHistory" class="card history-card animate-in"></div>
        </div>
      </div>
    </div><!-- /90ctest-view -->

    <!-- Paper Trading View -->
    <div id="paper-view" style="display:none">
      <div class="summary-grid animate-in">
        <div class="card stat-card paper">
          <div class="stat-label">Paper P&L</div>
          <div class="stat-value neutral" id="paperPnl">--</div>
        </div>
        <div class="card stat-card">
          <div class="stat-label">Record</div>
          <div class="stat-value neutral" id="paperWinRate">--</div>
          <div class="stat-detail" id="paperRecord">--</div>
        </div>
      </div>
      <div class="section-header">
        <span class="section-title">Paper Trades</span>
        <span class="paper-badge">SIMULATED</span>
      </div>
      <div class="card trades-card" id="paperTrades">
        <p class="loading">Loading paper trades...</p>
      </div>
    </div><!-- /paper-view -->

    <!-- Live Status View -->
    <div id="live-view" style="display:none">
      <!-- Status Panel -->
      <div class="card live-panel animate-in">
        <div class="live-header">
          <div id="live-badge" class="live-badge idle"><span class="dot"></span>--</div>
          <div class="live-header-right">
            <span id="live-ttl" class="live-ttl">--</span>
            <span id="live-stale" class="live-stale">--</span>
          </div>
        </div>
        <div class="live-grid">
          <div>
            <div class="live-label">UP Ask</div>
            <div class="live-value" id="live-up-ask">--</div>
          </div>
          <div>
            <div class="live-label">DN Ask</div>
            <div class="live-value" id="live-dn-ask">--</div>
          </div>
          <div>
            <div class="live-label">UP Pos</div>
            <div class="live-value" id="live-up-pos">0</div>
          </div>
          <div>
            <div class="live-label">DN Pos</div>
            <div class="live-value" id="live-dn-pos">0</div>
          </div>
          <div>
            <div class="live-label">BTC Price</div>
            <div class="live-value" id="live-btc">--</div>
          </div>
          <div>
            <div class="live-label">Danger</div>
            <div class="live-value" id="live-danger">--</div>
          </div>
        </div>
        <div class="live-reason" id="live-reason">--</div>
      </div>

      <!-- Price Chart -->
      <div style="margin-top: 16px;">
        <div class="section-header">
          <span class="section-title">Window Prices</span>
          <span class="section-badge" id="live-window-id">--</span>
        </div>
        <div class="card" id="liveChartCard" style="padding: 1rem;">
          <canvas id="liveCanvas" height="180"></canvas>
        </div>
      </div>

      <!-- Event Feed -->
      <div style="margin-top: 16px;">
        <div class="section-header">
          <span class="section-title">Recent Events</span>
        </div>
        <div class="card">
          <div class="event-feed" id="live-events">
            <p class="empty-state">Loading events...</p>
          </div>
        </div>
      </div>
    </div><!-- /live-view -->

    <!-- Footer -->
    <footer class="footer">
      <p class="footer-text" id="connectionStatus">
        <span class="status-dot"></span>
        Connecting...
      </p>
    </footer>
  </div>

  <script>
    // Configuration
    const CONFIG = {
      supabaseUrl: 'https://qszosdrmnoglrkttdevz.supabase.co',
      supabaseAnonKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFzem9zZHJtbm9nbHJrdHRkZXZ6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjkxOTg1NTYsImV4cCI6MjA4NDc3NDU1Nn0.-Ebe2icoMqIiL8NlVX93IJGVBCAmpfxk9S7U8ABsStA',
      walletAddress: '0x636796704404959f5Ae9BEfEb2B3880eadf6960a',
      historyStartDate: '2026-02-09',
      startingBalance: 82.15,
      // Set this to a unix timestamp (seconds) to start a fresh "day" from that point.
      // Pre-cutoff trades on the same calendar day get rolled into yesterday.
      // Set to null for normal calendar-day behavior.
      newDayAt: null
    };

    // Support both config and URL param (?from= overrides config)
    const fromParam = new URLSearchParams(window.location.search).get('from');
    const cutoffTs = fromParam ? parseInt(fromParam) : CONFIG.newDayAt;
    const FROM_CUTOFF = cutoffTs ? new Date(cutoffTs * 1000) : null;
    if (FROM_CUTOFF) console.log('[DASHBOARD] New day starts at:', FROM_CUTOFF.toLocaleString('en-US', { timeZone: 'America/New_York' }));

    const db = window.supabase.createClient(CONFIG.supabaseUrl, CONFIG.supabaseAnonKey);

    // Cache DOM elements
    const el = {
      date: document.getElementById('date'),
      error: document.getElementById('error'),
      errorMsg: document.getElementById('errorMsg'),
      todayPnl: document.getElementById('todayPnl'),
      winRate: document.getElementById('winRate'),
      record: document.getElementById('record'),
      roi: document.getElementById('roi'),
      trades: document.getElementById('trades'),
      history: document.getElementById('history')
    };

    // Helpers
    const fmtPnl = (n) => (n >= 0 ? '+' : '') + '$' + n.toFixed(2);
    const fmtPrice = (n) => Math.round(parseFloat(n) * 100) + 'Â¢';
    const parsePnl = (v) => { const n = parseFloat(v); return isNaN(n) ? 0 : n; };
    const escapeHtml = (s) => String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[c]));
    // IMPORTANT: Use EST timezone to match Supabase daily_summary view (which stores dates in EST)
    const getLocalDate = () => new Date().toLocaleDateString('en-CA', { timeZone: 'America/New_York' });

    function showError(msg) {
      el.error.classList.add('visible');
      el.errorMsg.textContent = msg;
    }

    function hideError() {
      el.error.classList.remove('visible');
    }


    let allTrades = [];
    let currentSummary = [];
    let showingAll = false;

    function getTodayTrades() {
      const today = getLocalDate();
      return allTrades.filter(t => {
        const tradeTime = new Date(t.timestamp);
        if (tradeTime.toLocaleDateString('en-CA', { timeZone: 'America/New_York' }) !== today) return false;
        if (FROM_CUTOFF && tradeTime < FROM_CUTOFF) return false;
        return true;
      });
    }

    let balanceChart = null;
    // Fetch latest BALANCE_SNAPSHOT from Supabase for calibration
    let latestBalanceSnapshot = null;
    async function fetchStartingBalance() {
      try {
        // Get the latest BALANCE_SNAPSHOT (most recent known wallet balance)
        const { data, error } = await db
          .from('Polymarket Bot Log - Events')
          .select('Details, Timestamp')
          .eq('Event', 'BALANCE_SNAPSHOT')
          .order('Timestamp', { ascending: false })
          .limit(1);

        if (!error && data && data.length > 0) {
          const details = typeof data[0].Details === 'string' ? data[0].Details : JSON.stringify(data[0].Details);
          const totalMatch = details.match(/total=([\d.]+)/);
          const dateMatch = details.match(/date=([\d-]+)/);
          if (totalMatch) {
            latestBalanceSnapshot = {
              total: parseFloat(totalMatch[1]),
              date: dateMatch ? dateMatch[1] : new Date(data[0].Timestamp).toLocaleDateString('en-CA', { timeZone: 'America/New_York' })
            };
            console.log('[DASHBOARD] Latest BALANCE_SNAPSHOT:', latestBalanceSnapshot);
          }
        }
        if (!latestBalanceSnapshot) {
          console.warn('[DASHBOARD] No BALANCE_SNAPSHOT found, using CONFIG.startingBalance');
        }
      } catch (e) {
        console.warn('[DASHBOARD] Could not fetch balance snapshot:', e);
      }
    }

    // Compute balance chart from daily P&L (no bot dependency)
    function updateBalanceChart(summary) {
      try {
        // Sort ALL days oldest first (includes pre-historyStartDate for accurate accumulation)
        const allDays = [...summary].sort((a, b) => a.trade_date.localeCompare(b.trade_date));

        if (!allDays.length) {
          document.getElementById('balanceChartCard').style.display = 'none';
          return;
        }

        // Calibrate starting balance: use latest BALANCE_SNAPSHOT and work backwards
        // effectiveStart = knownBalance - totalPnlFromAllDays
        // This ensures the chart ends at the actual wallet balance
        const totalPnl = allDays.reduce((s, d) => s + d.total_pnl, 0);
        let startBalance;
        if (latestBalanceSnapshot) {
          startBalance = Math.round((latestBalanceSnapshot.total - totalPnl) * 100) / 100;
          console.log('[DASHBOARD] Calibrated starting balance:', startBalance,
            '(snapshot:', latestBalanceSnapshot.total, '- total P&L:', Math.round(totalPnl * 100) / 100, ')');
        } else {
          startBalance = CONFIG.startingBalance;
        }

        const labels = [];
        const values = [];
        let running = startBalance;
        for (const day of allDays) {
          running += day.total_pnl;
          // Only add chart points from historyStartDate onwards
          if (day.trade_date >= CONFIG.historyStartDate) {
            labels.push(day.trade_date);
            values.push(Math.round(running * 100) / 100);
          }
        }

        if (!labels.length) {
          document.getElementById('balanceChartCard').style.display = 'none';
          return;
        }

        document.getElementById('balanceChartCard').style.display = 'block';

        if (balanceChart) {
          balanceChart.data.labels = labels;
          balanceChart.data.datasets[0].data = values;
          balanceChart.update();
          return;
        }

        balanceChart = new Chart(document.getElementById('balanceCanvas'), {
          type: 'line',
          data: {
            labels,
            datasets: [{
              label: 'Portfolio Balance ($)',
              data: values,
              borderColor: '#10b981',
              backgroundColor: 'rgba(16, 185, 129, 0.1)',
              fill: true,
              tension: 0.3,
              pointRadius: 4,
              pointBackgroundColor: '#10b981'
            }]
          },
          options: {
            responsive: true,
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: {
                  label: ctx => '$' + ctx.parsed.y.toFixed(2)
                }
              }
            },
            scales: {
              x: {
                ticks: { color: '#71717a', font: { family: 'JetBrains Mono', size: 10 } },
                grid: { color: 'rgba(255,255,255,0.04)' }
              },
              y: {
                ticks: {
                  color: '#71717a',
                  font: { family: 'JetBrains Mono', size: 10 },
                  callback: v => '$' + v.toFixed(0)
                },
                grid: { color: 'rgba(255,255,255,0.04)' }
              }
            }
          }
        });
      } catch (e) {
        console.warn('[DASHBOARD] Balance chart error:', e);
      }
    }

    // Build fill rate lookup: slug+side -> { fillRate, ordered, filled }
    async function buildFillRateMap() {
      try {
        const [fillRes, orderRes] = await Promise.all([
          db.from('Polymarket Bot Log - Events').select('Window ID, Side, Shares, Details')
            .eq('Event', 'CAPTURE_FILL').order('Timestamp', { ascending: false }).limit(200),
          db.from('Polymarket Bot Log - Events').select('Window ID, Side, Shares')
            .eq('Event', 'CAPTURE_99C').order('Timestamp', { ascending: false }).limit(200)
        ]);
        const fills = fillRes.data || [];
        const orders = orderRes.data || [];
        const orderMap = {};
        for (const o of orders) {
          if (o['Window ID']) orderMap[o['Window ID']] = parseFloat(o.Shares) || 0;
        }
        const map = {};
        for (const f of fills) {
          const wid = f['Window ID'];
          const side = (f.Side || '').toUpperCase();
          const filled = parseFloat(f.Shares) || 0;
          let fillRate = null, ordered = null;
          try {
            const d = typeof f.Details === 'string' ? JSON.parse(f.Details || '{}') : (f.Details || {});
            if (d.fill_rate != null) { fillRate = parseFloat(d.fill_rate); ordered = parseFloat(d.ordered_shares) || filled; }
          } catch (e) {}
          if (fillRate == null && orderMap[wid] && orderMap[wid] > 0) { ordered = orderMap[wid]; fillRate = filled / ordered; }
          if (wid) map[wid + '|' + side] = { fillRate, ordered, filled };
        }
        return map;
      } catch (e) {
        console.warn('[FILLRATE] buildFillRateMap error:', e);
        return {};
      }
    }

    async function loadData() {
      try {
        // Fetch Polymarket Activity API + Supabase fill data in parallel
        const activityUrl = `https://data-api.polymarket.com/activity?user=${CONFIG.walletAddress}&limit=1000`;
        const [allActivity, fillRateMap] = await Promise.all([
          fetch(activityUrl).then(r => r.ok ? r.json() : Promise.reject(new Error('Activity API: ' + r.status))),
          buildFillRateMap()
        ]);
        const polyTrades = allActivity.filter(a => a.type === 'TRADE');
        const redeemEvents = allActivity.filter(a => a.type === 'REDEEM');

        // Build redemption lookup: slug -> true (redeemed = won)
        const redeemed = new Set();
        for (const r of redeemEvents) {
          if (r.slug) redeemed.add(r.slug);
        }
        console.log(`[DASHBOARD] ${polyTrades.length} trades, ${redeemed.size} redeemed slugs`);

        let trades;

        if (polyTrades) {
          // PRIMARY: Build trades from Polymarket API (real fill prices)
          // Each fill is its own row; sells matched to buys via FIFO
          console.log(`[DASHBOARD] Loaded ${polyTrades.length} trades from Polymarket API`);
          const grouped = {};
          for (const t of polyTrades) {
            const slug = t.slug || '';
            const outcome = (t.outcome || '').toUpperCase();
            const key = slug + '|' + outcome;
            if (!grouped[key]) grouped[key] = { buys: [], sells: [], title: '' };
            if (t.title) grouped[key].title = t.title;
            const entry = {
              timestamp: t.timestamp,
              size: parseFloat(t.size) || 0,
              price: parseFloat(t.price) || 0,
              conditionId: t.conditionId || '',
              outcomeIndex: t.outcomeIndex ?? -1
            };
            if ((t.side || '').toUpperCase() === 'SELL') {
              grouped[key].sells.push(entry);
            } else {
              grouped[key].buys.push(entry);
            }
          }

          trades = [];
          for (const [key, group] of Object.entries(grouped)) {
            const [slug, side] = key.split('|');
            if (group.buys.length === 0) continue;
            // Skip 90c bot groups (all buys are 5-8 shares)
            const all90c = group.buys.every(b => b.size > 5 && b.size < 8);
            if (all90c) continue;
            const won = redeemed.has(slug);
            const windowTitle = group.title;

            // Sort buys by timestamp, sells by timestamp
            group.buys.sort((a, b) => a.timestamp - b.timestamp);
            group.sells.sort((a, b) => a.timestamp - b.timestamp);

            // Match sells to buys FIFO: consume sell shares from earliest buys first
            let sellPool = group.sells.map(s => ({ ...s, remaining: s.size }));
            const buyExitInfo = group.buys.map(() => ({ exitShares: 0, exitRevenue: 0 }));

            for (const sell of sellPool) {
              for (let i = 0; i < group.buys.length && sell.remaining > 0.001; i++) {
                const canMatch = group.buys[i].size - buyExitInfo[i].exitShares;
                if (canMatch <= 0.001) continue;
                const matched = Math.min(sell.remaining, canMatch);
                buyExitInfo[i].exitShares += matched;
                buyExitInfo[i].exitRevenue += matched * sell.price;
                sell.remaining -= matched;
              }
            }

            // Create one row per buy (skip dust < 0.1 shares)
            group.buys.forEach((buy, i) => {
              if (buy.size < 0.1) return;
              const info = buyExitInfo[i];
              const cost = buy.size * buy.price;
              const exitedAll = info.exitShares >= buy.size - 0.02;
              const hasExit = info.exitShares > 0.001;

              if (exitedAll) {
                // Fully exited â€” CASHED (profitable sell) or EXIT (loss-saving)
                const pnl = info.exitRevenue - cost;
                const exitPrice = info.exitShares > 0 ? info.exitRevenue / info.exitShares : 0;
                const isCashedOut = pnl > 0 && exitPrice >= 0.98;
                trades.push({
                  timestamp: new Date(buy.timestamp * 1000).toISOString(),
                  window_id: slug, side,
                  shares: buy.size, entry_price: buy.price,
                  exit_price: exitPrice,
                  status: isCashedOut ? 'CASHED' : 'EXIT',
                  profit_loss: Math.round(pnl * 100) / 100,
                  cost_basis: Math.round(cost * 100) / 100,
                  conditionId: buy.conditionId, outcomeIndex: buy.outcomeIndex, window_title: windowTitle
                });
              } else if (hasExit) {
                // Partially exited â€” split into CASHED/EXIT portion + remaining WIN/LOSS
                const remainShares = buy.size - info.exitShares;
                const exitCost = info.exitShares * buy.price;
                const exitPnl = info.exitRevenue - exitCost;
                const exitPrice = info.exitShares > 0 ? info.exitRevenue / info.exitShares : 0;
                const isPartialCash = exitPnl > 0 && exitPrice >= 0.98;
                trades.push({
                  timestamp: new Date(buy.timestamp * 1000).toISOString(),
                  window_id: slug, side,
                  shares: info.exitShares, entry_price: buy.price,
                  exit_price: exitPrice,
                  status: isPartialCash ? 'CASHED' : 'EXIT',
                  profit_loss: Math.round(exitPnl * 100) / 100,
                  cost_basis: Math.round(exitCost * 100) / 100,
                  conditionId: buy.conditionId, outcomeIndex: buy.outcomeIndex, window_title: windowTitle
                });
                const remainCost = remainShares * buy.price;
                // Resolve remaining portion: redeemed=WIN, old+not redeemed=LOSS
                const remainAge = Date.now() / 1000 - buy.timestamp;
                const remainStatus = won ? 'WIN' : (remainAge > 1800 ? 'LOSS' : 'PENDING');
                const remainPnl = remainStatus === 'WIN' ? remainShares * (1 - buy.price) : (remainStatus === 'LOSS' ? -remainCost : 0);
                trades.push({
                  timestamp: new Date(buy.timestamp * 1000).toISOString(),
                  window_id: slug, side,
                  shares: remainShares, entry_price: buy.price,
                  status: remainStatus,
                  profit_loss: Math.round(remainPnl * 100) / 100,
                  cost_basis: Math.round(remainCost * 100) / 100,
                  conditionId: buy.conditionId, outcomeIndex: buy.outcomeIndex, window_title: windowTitle
                });
              } else {
                // No exit â€” resolve via redemption data
                // redeemed=WIN, >30min old + not redeemed=LOSS, else PENDING
                const age = Date.now() / 1000 - buy.timestamp;
                const status = won ? 'WIN' : (age > 1800 ? 'LOSS' : 'PENDING');
                const pnl = status === 'WIN' ? buy.size * (1 - buy.price) : (status === 'LOSS' ? -cost : 0);
                trades.push({
                  timestamp: new Date(buy.timestamp * 1000).toISOString(),
                  window_id: slug, side,
                  shares: buy.size, entry_price: buy.price,
                  status,
                  profit_loss: Math.round(pnl * 100) / 100,
                  cost_basis: Math.round(cost * 100) / 100,
                  conditionId: buy.conditionId, outcomeIndex: buy.outcomeIndex, window_title: windowTitle
                });
              }
            });
          }
        }

        // Enrich trades with fill rate from Supabase data
        for (const t of trades) {
          const key = (t.window_id || '') + '|' + (t.side || '').toUpperCase();
          const fr = fillRateMap[key];
          t.fill_rate = fr ? fr.fillRate : null;
        }

        // Sort by timestamp descending
        trades.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

        // Build daily summary by aggregating trades by date (EST)
        // When ?from= is set, pre-cutoff trades on the same calendar day
        // get shifted to the previous day â€” so "today" starts fresh.
        const cutoffDate = FROM_CUTOFF
          ? FROM_CUTOFF.toLocaleDateString('en-CA', { timeZone: 'America/New_York' })
          : null;
        const dateGroups = {};
        for (const t of trades) {
          const tradeTime = new Date(t.timestamp);
          let d = tradeTime.toLocaleDateString('en-CA', { timeZone: 'America/New_York' });
          if (FROM_CUTOFF && d === cutoffDate && tradeTime < FROM_CUTOFF) {
            const prev = new Date(FROM_CUTOFF.getTime() - 86400000);
            d = prev.toLocaleDateString('en-CA', { timeZone: 'America/New_York' });
          }
          if (!dateGroups[d]) dateGroups[d] = [];
          dateGroups[d].push(t);
        }

        const summary = Object.entries(dateGroups).map(([date, dayTrades]) => {
          // Classify each window once: EXIT > LOSS > CASHED/WIN > PENDING
          // CASHED = profitable sell (profit lock filled), counts as a win
          const windowStatus = {};
          for (const t of dayTrades) {
            const wid = t.window_id;
            const cur = windowStatus[wid];
            if (t.status === 'EXIT' && cur !== 'EXIT') windowStatus[wid] = 'EXIT';
            else if (t.status === 'LOSS' && cur !== 'EXIT') windowStatus[wid] = 'LOSS';
            else if (t.status === 'CASHED' && (!cur || cur === 'PENDING' || cur === 'WIN')) windowStatus[wid] = 'CASHED';
            else if (t.status === 'WIN' && (!cur || cur === 'PENDING')) windowStatus[wid] = 'WIN';
            else if (!cur) windowStatus[wid] = 'PENDING';
          }
          const statuses = Object.values(windowStatus);
          const wins = statuses.filter(s => s === 'WIN').length;
          const cashed = statuses.filter(s => s === 'CASHED').length;
          const losses = statuses.filter(s => s === 'LOSS').length;
          const exits = statuses.filter(s => s === 'EXIT').length;
          const pending = statuses.filter(s => s === 'PENDING').length;
          const totalPnl = dayTrades.reduce((s, t) => s + t.profit_loss, 0);
          const totalCost = dayTrades.reduce((s, t) => s + (t.cost_basis ?? t.shares * t.entry_price), 0);
          const numWindows = statuses.length;
          const avgTradeValue = numWindows > 0 ? totalCost / numWindows : 0;
          const resolved = wins + cashed + losses + exits;
          return {
            trade_date: date,
            total_trades: numWindows,
            wins, cashed, losses, exits, pending,
            win_rate_pct: resolved > 0 ? Math.round((wins + cashed) / resolved * 1000) / 10 : 0,
            total_pnl: totalPnl,
            roi_pct: avgTradeValue > 0 ? Math.round(totalPnl / avgTradeValue * 1000) / 10 : 0
          };
        }).sort((a, b) => b.trade_date.localeCompare(a.trade_date));

        hideError();
        const filteredSummary = summary.filter(s => s.trade_date >= CONFIG.historyStartDate);
        allTrades = trades;
        currentSummary = filteredSummary;
        const displayTrades = showingAll ? allTrades : getTodayTrades();
        renderDashboard(filteredSummary, displayTrades);
        updateBalanceChart(summary);

        // Fill Rate Analytics â€” fetch from Supabase in background (non-blocking)
        fetchFillRateData().catch(e => console.warn('[FILLRATE] Error:', e));
      } catch (error) {
        console.error('Dashboard error:', error);
        showError(error.message + ' - will retry');
      }
    }

    // â”€â”€ Fill Rate Analytics â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async function fetchFillRateData() {
      const [fillRes, orderRes] = await Promise.all([
        db.from('Polymarket Bot Log - Events').select('*')
          .eq('Event', 'CAPTURE_FILL')
          .order('Timestamp', { ascending: false })
          .limit(200),
        db.from('Polymarket Bot Log - Events').select('Window ID, Shares')
          .eq('Event', 'CAPTURE_99C')
          .order('Timestamp', { ascending: false })
          .limit(200)
      ]);

      const fills = fillRes.data || [];
      const orders = orderRes.data || [];
      if (!fills.length) {
        document.getElementById('fillRateSection').style.display = 'none';
        return;
      }

      // Build order lookup: Window ID -> ordered shares
      const orderMap = {};
      for (const o of orders) {
        if (o['Window ID']) orderMap[o['Window ID']] = parseFloat(o.Shares) || 0;
      }

      // Build fill rate records
      const fillRecords = [];
      for (const f of fills) {
        const side = f.Side || '?';
        const filled = parseFloat(f.Shares) || 0;
        const ts = f.Timestamp;
        let fillRate = null;
        let ordered = null;

        // Try parsing from Details JSON (new events with embedded fill_rate)
        try {
          const details = typeof f.Details === 'string' ? JSON.parse(f.Details || '{}') : (f.Details || {});
          if (details.fill_rate != null) {
            fillRate = parseFloat(details.fill_rate);
            ordered = parseFloat(details.ordered_shares) || filled;
          }
        } catch (e) { /* ignore parse errors */ }

        // Fallback: join with CAPTURE_99C on Window ID
        if (fillRate == null) {
          const ord = orderMap[f['Window ID']];
          if (ord && ord > 0) {
            ordered = ord;
            fillRate = filled / ord;
          }
        }

        fillRecords.push({ ts, side, filled, ordered, fillRate });
      }

      renderFillRateAnalytics(fillRecords);
    }

    function renderFillRateAnalytics(records) {
      const section = document.getElementById('fillRateSection');
      const withRate = records.filter(r => r.fillRate != null);

      if (!withRate.length) {
        section.style.display = 'none';
        return;
      }
      section.style.display = '';

      // Badge count
      document.getElementById('fillRateCount').textContent = withRate.length + ' fills';

      // Avg fill rate
      const avgRate = withRate.reduce((s, r) => s + r.fillRate, 0) / withRate.length;
      const avgEl = document.getElementById('avgFillRate');
      avgEl.textContent = Math.round(avgRate * 100) + '%';
      avgEl.className = 'stat-value ' + (avgRate >= 1 ? 'positive' : avgRate >= 0.8 ? '' : 'negative');

      // By direction
      const upRates = withRate.filter(r => (r.side || '').toUpperCase() === 'UP');
      const dnRates = withRate.filter(r => (r.side || '').toUpperCase() === 'DOWN');
      const upAvg = upRates.length ? upRates.reduce((s, r) => s + r.fillRate, 0) / upRates.length : null;
      const dnAvg = dnRates.length ? dnRates.reduce((s, r) => s + r.fillRate, 0) / dnRates.length : null;

      const upEl = document.getElementById('upFillRate');
      upEl.textContent = upAvg != null ? Math.round(upAvg * 100) + '%' : '--';
      upEl.className = 'stat-value' + (upAvg != null ? (upAvg >= 1 ? ' positive' : upAvg >= 0.8 ? '' : ' negative') : '');

      const dnEl = document.getElementById('dnFillRate');
      dnEl.textContent = dnAvg != null ? Math.round(dnAvg * 100) + '%' : '--';
      dnEl.className = 'stat-value' + (dnAvg != null ? (dnAvg >= 1 ? ' positive' : dnAvg >= 0.8 ? '' : ' negative') : '');

      // By hour (EST)
      const hourBuckets = {};
      for (const r of withRate) {
        const h = new Date(r.ts).toLocaleString('en-US', { hour: 'numeric', hour12: true, timeZone: 'America/New_York' });
        if (!hourBuckets[h]) hourBuckets[h] = [];
        hourBuckets[h].push(r.fillRate);
      }
      const hourContainer = document.getElementById('fillRateByHour');
      if (Object.keys(hourBuckets).length > 0) {
        const bars = Object.entries(hourBuckets)
          .sort((a, b) => {
            const toNum = s => { const m = s.match(/(\d+)\s*(AM|PM)/i); if (!m) return 0; let h = parseInt(m[1]); if (m[2].toUpperCase() === 'PM' && h !== 12) h += 12; if (m[2].toUpperCase() === 'AM' && h === 12) h = 0; return h; };
            return toNum(a[0]) - toNum(b[0]);
          })
          .map(([hour, rates]) => {
            const avg = rates.reduce((s, v) => s + v, 0) / rates.length;
            const pct = Math.round(avg * 100);
            const h = Math.max(4, Math.round(avg * 48));
            const color = avg >= 1 ? 'var(--green-primary)' : avg >= 0.8 ? 'var(--text-secondary)' : 'var(--yellow-primary)';
            return `<div class="fillrate-bar" style="height:${h}px; background:${color};" title="${hour}: ${pct}% (${rates.length} fills)"><span class="fillrate-bar-label">${hour.replace(' ', '')}</span></div>`;
          }).join('');
        hourContainer.innerHTML = bars;
        hourContainer.style.paddingBottom = '18px';
      } else {
        hourContainer.innerHTML = '<span style="color:var(--text-muted); font-size:12px;">No data</span>';
      }

      // Recent fills table (last 20)
      const recent = records.slice(0, 20);
      const tableEl = document.getElementById('fillRateTable');
      const header = `<div class="fillrate-row header"><span>Time</span><span>Side</span><span>Order</span><span>Fill</span><span class="fillrate-pct">Rate</span></div>`;
      const rows = recent.map(r => {
        const time = new Date(r.ts).toLocaleTimeString('en-US', {
          hour: 'numeric', minute: '2-digit', hour12: true, timeZone: 'America/New_York'
        });
        const side = (r.side || '?').toUpperCase();
        const ord = r.ordered != null ? Math.round(r.ordered) : '--';
        const fil = Math.round(r.filled);
        let rateTxt = '--';
        let rateClass = 'white';
        if (r.fillRate != null) {
          const pct = Math.round(r.fillRate * 100);
          rateTxt = pct + '%';
          rateClass = pct >= 100 ? 'green' : pct >= 80 ? 'white' : 'orange';
        }
        return `<div class="fillrate-row"><span>${time}</span><span>${side}</span><span>${ord}</span><span>${fil}</span><span class="fillrate-pct ${rateClass}">${rateTxt}</span></div>`;
      }).join('');
      tableEl.innerHTML = header + rows;
    }

    function groupTradesByWindow(trades) {
      const groups = {};
      const order = [];
      for (const t of trades) {
        const key = t.window_id || t.timestamp;
        if (!groups[key]) {
          groups[key] = [];
          order.push(key);
        }
        groups[key].push(t);
      }
      return order.map(key => groups[key]);
    }

    function renderDashboard(summary, trades) {
      const today = getLocalDate();

      // Update date display (EST for consistency)
      const dateStr = new Date().toLocaleDateString('en-US', {
        weekday: 'long', month: 'short', day: 'numeric', timeZone: 'America/New_York'
      });
      el.date.innerHTML = `<span class="status-dot"></span>${dateStr}`;

      // Today's summary
      const todayData = summary.find(d => d.trade_date === today);
      if (todayData) {
        const pnl = parsePnl(todayData.total_pnl);
        el.todayPnl.textContent = fmtPnl(pnl);
        el.todayPnl.className = 'stat-value ' + (pnl >= 0 ? 'positive' : 'negative');

        el.winRate.textContent = (todayData.win_rate_pct ?? 0) + '%';
        el.winRate.className = 'stat-value ' + ((todayData.win_rate_pct ?? 0) >= 50 ? 'positive' : 'neutral');

        const pending = todayData.pending ?? 0;
        const exits = todayData.exits ?? 0;
        const cashed = todayData.cashed ?? 0;
        let recordText = (todayData.wins ?? 0) + 'W';
        if (cashed > 0) recordText += ' / ' + cashed + 'C';
        recordText += ' / ' + (todayData.losses ?? 0) + 'L';
        if (exits > 0) recordText += ' / ' + exits + 'E';
        if (pending > 0) recordText += ' (' + pending + ' pending)';
        el.record.textContent = recordText;

        const roiPct = todayData.roi_pct ?? 0;
        el.roi.textContent = (roiPct > 0 ? '+' : '') + roiPct + '% ROI';
        el.roi.className = 'stat-roi ' + (roiPct >= 0 ? 'positive' : 'negative');
      } else {
        el.todayPnl.textContent = '$0.00';
        el.todayPnl.className = 'stat-value neutral';
        el.winRate.textContent = '--';
        el.winRate.className = 'stat-value neutral';
        el.record.textContent = 'No trades yet';
        el.roi.textContent = '';
      }

      // Recent trades grouped by window
      if (trades.length > 0) {
        const windowGroups = groupTradesByWindow(trades);
        let lastDate = null;
        const statusPriority = { EXIT: 3, LOSS: 2, CASHED: 1.5, WIN: 1, PENDING: 0 };

        const tradesHtml = windowGroups.map(group => {
          const first = group[0];
          const firstDate = new Date(first.timestamp);
          const dateStr = firstDate.toLocaleDateString('en-CA', { timeZone: 'America/New_York' });

          // Date separator
          let separator = '';
          if (lastDate !== dateStr) {
            const displayDate = firstDate.toLocaleDateString('en-US', {
              weekday: 'short', month: 'short', day: 'numeric', timeZone: 'America/New_York'
            });
            separator = `<div class="date-separator">${displayDate}</div>`;
            lastDate = dateStr;
          }

          // Single-fill window: render as regular trade row (unchanged)
          if (group.length === 1) {
            const t = first;
            const status = t.status || 'PENDING';
            const pnl = parsePnl(t.profit_loss);
            const isPending = status === 'PENDING';
            const isWin = status === 'WIN';
            const isCashed = status === 'CASHED';
            const isExit = status === 'EXIT';
            const price = fmtPrice(t.entry_price ?? 0.99);
            const time = firstDate.toLocaleTimeString('en-US', {
              hour: 'numeric', minute: '2-digit', hour12: true, timeZone: 'America/New_York'
            });
            const side = escapeHtml(t.side ?? '?');
            const rawShares = t.shares || 0;
            const shares = rawShares % 1 < 0.01 ? Math.round(rawShares) : rawShares.toFixed(2);
            const statusClass = isPending ? 'pending' : isCashed ? 'profit-lock' : isExit ? 'exit' : (isWin ? 'win' : 'loss');
            const statusIcon = isPending ? 'â—·' : isCashed ? 'ðŸ’°' : isExit ? 'â†©' : (isWin ? 'âœ“' : 'âœ—');
            const pnlClass = isPending ? 'pending' : isCashed ? 'positive' : isExit ? 'exit' : (isWin ? 'positive' : 'negative');
            const pnlText = isPending ? 'pending' : fmtPnl(pnl);
            const costBasis = t.cost_basis ?? (t.shares * t.entry_price);
            const roiPct = costBasis > 0 && !isPending ? Math.round(pnl / costBasis * 1000) / 10 : null;
            const roiText = roiPct !== null ? `<span class="roi ${roiPct >= 0 ? 'positive' : 'negative'}">${roiPct > 0 ? '+' : ''}${roiPct}%</span>` : '';
            const fr = t.fill_rate;
            const frText = fr != null ? `<span class="fill-badge ${fr >= 1 ? 'green' : fr >= 0.8 ? '' : 'orange'}">${Math.round(fr * 100)}%</span>` : '';

            return separator + `
              <div class="trade-item">
                <div class="trade-status ${statusClass}">${statusIcon}</div>
                <div class="trade-info">
                  <div class="trade-pair">${side} ${shares}@${price}${(isExit || isCashed) ? ' \u2192 ' + fmtPrice(t.exit_price ?? 0) : ''}${frText ? ' ' + frText : ''}</div>
                  <div class="trade-detail">$${costBasis.toFixed(2)} \u00b7 ${roiText || '--'}</div>
                  <div class="trade-meta">${(() => {
                    const title = t.window_title || '';
                    const m = title.match(/(\d{1,2}:\d{2}[AP]M-\d{1,2}:\d{2}[AP]M\s*ET)/);
                    return m ? m[1] : time;
                  })()}</div>
                </div>
                <div class="trade-pnl ${pnlClass}">${pnlText}</div>
              </div>
            `;
          }

          // Multi-fill window: render summary + collapsible fills
          const totalShares = group.reduce((s, t) => s + (t.shares || 0), 0);
          const totalCost = group.reduce((s, t) => s + (t.cost_basis ?? (t.shares * t.entry_price)), 0);
          const avgPrice = totalShares > 0 ? totalCost / totalShares : 0;
          const totalPnl = group.reduce((s, t) => s + parsePnl(t.profit_loss), 0);

          // Window-level status (priority: EXIT > LOSS > WIN > PENDING)
          const winStatus = group.reduce((best, t) => {
            const ts = t.status || 'PENDING';
            return (statusPriority[ts] ?? 0) > (statusPriority[best] ?? 0) ? ts : best;
          }, group[0].status || 'PENDING');

          const isPending = winStatus === 'PENDING';
          const isWin = winStatus === 'WIN';
          const isCashed = winStatus === 'CASHED';
          const isExit = winStatus === 'EXIT';
          const statusClass = isPending ? 'pending' : isCashed ? 'profit-lock' : isExit ? 'exit' : (isWin ? 'win' : 'loss');
          const statusIcon = isPending ? 'â—·' : isCashed ? 'ðŸ’°' : isExit ? 'â†©' : (isWin ? 'âœ“' : 'âœ—');
          const pnlClass = isPending ? 'pending' : isCashed ? 'positive' : isExit ? 'exit' : (totalPnl >= 0 ? 'positive' : 'negative');
          const pnlText = isPending ? 'pending' : fmtPnl(totalPnl);

          // Determine side label (handle mixed UP+DN)
          const sides = [...new Set(group.map(t => t.side).filter(Boolean))];
          const sideLabel = sides.length > 1 ? sides.join('+') : escapeHtml(sides[0] ?? '?');

          const fmtShares = totalShares % 1 < 0.01 ? Math.round(totalShares) : totalShares.toFixed(2);
          const roiPct = totalCost > 0 && !isPending ? Math.round(totalPnl / totalCost * 1000) / 10 : null;
          const roiText = roiPct !== null ? `<span class="roi ${roiPct >= 0 ? 'positive' : 'negative'}">${roiPct > 0 ? '+' : ''}${roiPct}%</span>` : '';

          // Window time from first trade's window_title
          const windowTime = (() => {
            const title = first.window_title || '';
            const m = title.match(/(\d{1,2}:\d{2}[AP]M-\d{1,2}:\d{2}[AP]M\s*ET)/);
            if (m) return m[1];
            return firstDate.toLocaleTimeString('en-US', {
              hour: 'numeric', minute: '2-digit', hour12: true, timeZone: 'America/New_York'
            });
          })();

          // Fill rate for window summary (use first trade's fill_rate)
          const wFr = first.fill_rate;
          const wFrText = wFr != null ? `<span class="fill-badge ${wFr >= 1 ? 'green' : wFr >= 0.8 ? '' : 'orange'}">${Math.round(wFr * 100)}%</span>` : '';

          // Summary row
          const summaryHtml = `
            <div class="trade-item window-summary">
              <div class="trade-status ${statusClass}">${statusIcon}</div>
              <div class="trade-info">
                <div class="trade-pair"><span class="chevron">\u25B6</span>${sideLabel} ${fmtShares}@${fmtPrice(avgPrice)}${wFrText ? ' ' + wFrText : ''}</div>
                <div class="trade-detail">$${totalCost.toFixed(2)} \u00b7 ${roiText || '--'}</div>
                <div class="trade-meta">${windowTime} \u00b7 <span class="fill-count">${group.length} fills</span></div>
              </div>
              <div class="trade-pnl ${pnlClass}">${pnlText}</div>
            </div>
          `;

          // Individual fill rows
          const fillsHtml = group.map(t => {
            const s = t.status || 'PENDING';
            const pnl = parsePnl(t.profit_loss);
            const sp = s === 'PENDING';
            const sw = s === 'WIN';
            const se = s === 'EXIT';
            const sc = sp ? 'pending' : se ? 'exit' : (sw ? 'win' : 'loss');
            const si = sp ? 'â—·' : se ? 'â†©' : (sw ? 'âœ“' : 'âœ—');
            const pc = sp ? 'pending' : se ? 'exit' : (sw ? 'positive' : 'negative');
            const pt = sp ? 'pending' : fmtPnl(pnl);
            const side = escapeHtml(t.side ?? '?');
            const rawS = t.shares || 0;
            const sh = rawS % 1 < 0.01 ? Math.round(rawS) : rawS.toFixed(2);
            const cb = t.cost_basis ?? (t.shares * t.entry_price);
            return `
              <div class="trade-item">
                <div class="trade-status ${sc}">${si}</div>
                <div class="trade-info">
                  <div class="trade-pair">${side} ${sh}@${fmtPrice(t.entry_price ?? 0.99)}${se ? ' \u2192 ' + fmtPrice(t.exit_price ?? 0) : ''}</div>
                  <div class="trade-detail">$${cb.toFixed(2)}</div>
                </div>
                <div class="trade-pnl ${pc}">${pt}</div>
              </div>
            `;
          }).join('');

          return separator + `
            <div class="window-group">
              ${summaryHtml}
              <div class="window-fills">${fillsHtml}</div>
            </div>
          `;
        }).join('');

        el.trades.innerHTML = tradesHtml;
      } else {
        el.trades.innerHTML = '<p class="empty-state">No trades yet</p>';
      }

      // Daily history
      if (summary.length > 0) {
        const historyHtml = summary.map(d => {
          const pnl = parsePnl(d.total_pnl);
          const date = new Date(d.trade_date + 'T12:00:00').toLocaleDateString('en-US', {
            month: 'short', day: 'numeric', timeZone: 'America/New_York'
          });
          const wins = d.wins ?? 0;
          const cashed = d.cashed ?? 0;
          const losses = d.losses ?? 0;
          const exits = d.exits ?? 0;
          const roiPct = d.roi_pct ?? 0;
          let record = `${wins}W`;
          if (cashed > 0) record += `/${cashed}C`;
          record += `/${losses}L`;
          if (exits > 0) record += `/${exits}E`;

          return `
            <div class="history-item">
              <span class="history-date">${escapeHtml(date)}</span>
              <span class="history-pnl ${pnl >= 0 ? 'positive' : 'negative'}">${fmtPnl(pnl)}</span>
              <span class="history-record">${record}</span>
              <span class="history-roi ${roiPct >= 0 ? 'positive' : 'negative'}">${roiPct > 0 ? '+' : ''}${roiPct}%</span>
            </div>
          `;
        }).join('');
        el.history.innerHTML = historyHtml;
      } else {
        el.history.innerHTML = '<p class="empty-state">No history yet</p>';
      }
    }

    // Connection state
    let refreshInterval;
    let realtimeChannel = null;
    let isRealtimeConnected = false;
    const BACKUP_POLL_MS = 300000; // 5 minutes backup polling

    const statusEl = document.getElementById('connectionStatus');

    function updateStatus(status, isLive = false) {
      const dotStyle = isLive ? '' : 'style="background: var(--yellow-primary);"';
      statusEl.innerHTML = `<span class="status-dot" ${dotStyle}></span>${status}`;
      console.log('[STATUS]', status);
    }

    const debugLog = (msg) => console.log('[DEBUG]', msg);

    function startBackupPolling() {
      stopRefresh();
      refreshInterval = setInterval(loadData, BACKUP_POLL_MS);
    }

    function stopRefresh() {
      if (refreshInterval) {
        clearInterval(refreshInterval);
        refreshInterval = null;
      }
    }

    // Supabase Realtime subscription
    function setupRealtime() {
      if (realtimeChannel) {
        db.removeChannel(realtimeChannel);
      }

      updateStatus('Connecting...');
      debugLog('Setting up realtime...');

      realtimeChannel = db
        .channel('polybot-live')
        .on(
          'postgres_changes',
          {
            event: 'INSERT',
            schema: 'public',
            table: 'Polymarket Bot Log - Events'
          },
          (payload) => {
            const evt = payload.new?.Event || '';
            console.log('[REALTIME] New event:', evt);

            // Live status: always feed events into the live panel
            if (payload.new) prependEvent(payload.new);

            // Paper tab: reload on paper trade events
            if (evt.startsWith('PAPER_') && paperDataLoaded) {
              loadPaperData();
            }

            // Trades tab: reload on trade-affecting events
            if (['CAPTURE_FILL', 'CAPTURE_99C_WIN', 'CAPTURE_99C_LOSS'].includes(evt)) {
              updateStatus('\u26A1 Update received', true);
              loadData();
              setTimeout(() => {
                if (isRealtimeConnected) {
                  updateStatus('Live', true);
                }
              }, 1000);
            }
          }
        )
        .on(
          'postgres_changes',
          {
            event: 'INSERT',
            schema: 'public',
            table: 'Polymarket Bot Log - Ticks'
          },
          (payload) => {
            const tick = payload.new;
            if (!tick) return;
            // Always update state (cheap), only update DOM if on live tab
            updateLivePanel(tick);
            if (activeTab === 'live') appendTickToChart(tick);
          }
        )
        .subscribe((status, err) => {
          console.log('[REALTIME] Status:', status, err);
          debugLog('Realtime: ' + status + (err ? ' - ' + err.message : ''));

          if (status === 'SUBSCRIBED') {
            isRealtimeConnected = true;
            updateStatus('Live', true);
            debugLog('Connected! Listening for events...');
            startBackupPolling();
          } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {
            isRealtimeConnected = false;
            updateStatus('Polling (realtime unavailable)');
            debugLog('Error: ' + (err?.message || status));
            stopRefresh();
            refreshInterval = setInterval(loadData, 10000);
          } else if (status === 'CLOSED') {
            isRealtimeConnected = false;
            updateStatus('Reconnecting...');
            setTimeout(setupRealtime, 5000);
          }
        });
    }

    // Handle tab visibility
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        stopRefresh();
      } else {
        loadData();
        if (isRealtimeConnected) {
          startBackupPolling();
        } else {
          setupRealtime();
        }
      }
    });

    // â”€â”€ Live Status Tab â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    let activeTab = 'trades';
    let liveChart = null;
    let lastTickTime = null;
    let currentWindowId = null;
    let liveEvents = [];
    let liveDataLoaded = false;
    let test90cDataLoaded = false;

    // Tab switching (no hash routing â€” just toggle display)
    function switchTab(tab) {
      activeTab = tab;
      document.getElementById('trades-view').style.display = tab === 'trades' ? '' : 'none';
      document.getElementById('90ctest-view').style.display = tab === '90ctest' ? '' : 'none';
      document.getElementById('paper-view').style.display = tab === 'paper' ? '' : 'none';
      document.getElementById('live-view').style.display = tab === 'live' ? '' : 'none';
      document.querySelectorAll('.tab').forEach(t => {
        t.classList.toggle('active', t.dataset.tab === tab);
      });
      if (tab === 'live' && !liveDataLoaded) {
        loadLiveData();
      }
      if (tab === 'paper' && !paperDataLoaded) {
        loadPaperData();
      }
      if (tab === '90ctest' && !test90cDataLoaded) {
        load90cTestData();
      }
    }

    document.querySelectorAll('.tab').forEach(btn => {
      btn.addEventListener('click', () => switchTab(btn.dataset.tab));
    });

    // Fetch initial live data from Supabase
    async function loadLiveData() {
      try {
        console.log('[LIVE] Loading live data...');

        // Get latest tick to determine current window
        const { data: latestTicks, error: tickErr } = await db
          .from('Polymarket Bot Log - Ticks')
          .select('*')
          .order('Timestamp', { ascending: false })
          .limit(1);

        if (tickErr) console.error('[LIVE] Tick query error:', tickErr);

        if (latestTicks && latestTicks.length > 0) {
          const tick = latestTicks[0];
          console.log('[LIVE] Latest tick:', tick['Status'], 'TTL:', tick['TTL']);
          currentWindowId = tick['Window ID'];
          updateLivePanel(tick);

          // Load ticks for current window (for chart)
          const { data: windowTicks, error: windowErr } = await db
            .from('Polymarket Bot Log - Ticks')
            .select('*')
            .eq('Window ID', currentWindowId)
            .order('Timestamp', { ascending: true });

          if (windowErr) console.error('[LIVE] Window ticks error:', windowErr);
          if (windowTicks) {
            console.log('[LIVE] Window ticks loaded:', windowTicks.length);
            renderLiveChart(windowTicks);
          }
        } else {
          console.warn('[LIVE] No ticks found');
          document.getElementById('live-reason').textContent = 'No tick data available';
        }

        // Load recent events
        const { data: events, error: evtErr } = await db
          .from('Polymarket Bot Log - Events')
          .select('*')
          .order('Timestamp', { ascending: false })
          .limit(25);

        if (evtErr) console.error('[LIVE] Events query error:', evtErr);
        if (events) {
          console.log('[LIVE] Events loaded:', events.length);
          liveEvents = events;
          renderEventFeed();
        }

        liveDataLoaded = true;
      } catch (e) {
        console.error('[LIVE] Error loading data:', e);
        document.getElementById('live-reason').textContent = 'Error: ' + e.message;
      }
    }

    // Update the status panel from a tick row
    function updateLivePanel(tick) {
      lastTickTime = new Date(tick['Timestamp']);

      const status = tick['Status'] || '--';
      const ttl = parseInt(tick['TTL']) || 0;
      const upAsk = parseFloat(tick['UP Ask']) || 0;
      const dnAsk = parseFloat(tick['DN Ask']) || 0;
      const upPos = parseFloat(tick['UP Pos']) || 0;
      const dnPos = parseFloat(tick['DN Pos']) || 0;
      const btc = parseFloat(tick['BTC']) || 0;
      const danger = tick['Reason 2'] ? parseFloat(tick['Reason 2']) : null;
      const reason = tick['Reason'] || '';
      const newWindowId = tick['Window ID'] || '';

      // Detect window transition â†’ reset chart
      if (currentWindowId && newWindowId && newWindowId !== currentWindowId) {
        currentWindowId = newWindowId;
        if (liveChart) {
          liveChart.data.labels = [];
          liveChart.data.datasets[0].data = [];
          liveChart.data.datasets[1].data = [];
          liveChart.update();
        }
      }
      currentWindowId = newWindowId;

      // Compensate TTL for flush latency: actual TTL â‰ˆ stored TTL - age of tick
      const tickAge = Math.max(0, (Date.now() - lastTickTime.getTime()) / 1000);
      const adjustedTtl = Math.max(0, Math.round(ttl - tickAge));

      // Update DOM
      const badge = document.getElementById('live-badge');
      const statusLower = status.toLowerCase();
      badge.className = 'live-badge ' + statusLower;
      badge.innerHTML = '<span class="dot"></span>' + status;
      document.getElementById('live-ttl').textContent = adjustedTtl > 0 ? 'T-' + adjustedTtl + 's' : 'WAIT';
      document.getElementById('live-up-ask').textContent = Math.round(upAsk * 100) + '\u00A2';
      document.getElementById('live-dn-ask').textContent = Math.round(dnAsk * 100) + '\u00A2';
      document.getElementById('live-up-pos').textContent = upPos;
      document.getElementById('live-dn-pos').textContent = dnPos;
      document.getElementById('live-btc').textContent = '$' + btc.toLocaleString('en-US', { maximumFractionDigits: 0 });
      document.getElementById('live-danger').textContent = danger !== null ? danger.toFixed(2) : '--';
      document.getElementById('live-reason').textContent = reason;

      // Window ID badge
      const wid = currentWindowId.replace('btc-updown-15m-', '');
      document.getElementById('live-window-id').textContent = wid || '--';
    }

    // Staleness indicator â€” updated every second
    setInterval(() => {
      if (!lastTickTime) return;
      const age = Math.round((Date.now() - lastTickTime.getTime()) / 1000);
      const el = document.getElementById('live-stale');
      el.textContent = 'Last: ' + age + 's';
      // Yellow after 90s (3 missed flushes), red after 300s
      el.className = 'live-stale' + (age < 90 ? '' : age < 300 ? ' warning' : ' stale');
    }, 1000);

    // Clock â€” PST & EST updated every second
    function updateClock() {
      const now = new Date();
      const fmt = { hour: 'numeric', minute: '2-digit', second: '2-digit', hour12: true };
      const pst = now.toLocaleTimeString('en-US', { ...fmt, timeZone: 'America/Los_Angeles' });
      const est = now.toLocaleTimeString('en-US', { ...fmt, timeZone: 'America/New_York' });
      document.getElementById('clock').textContent = pst + ' PST  Â· ' + est + ' EST';
    }
    updateClock();
    setInterval(updateClock, 1000);

    // â”€â”€ Live Chart â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function renderLiveChart(ticks) {
      const labels = [];
      const upData = [];
      const dnData = [];
      for (const t of ticks) {
        labels.push(new Date(t['Timestamp']).toLocaleTimeString('en-US', {
          hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false, timeZone: 'America/New_York'
        }));
        upData.push(Math.round(parseFloat(t['UP Ask']) * 100));
        dnData.push(Math.round(parseFloat(t['DN Ask']) * 100));
      }

      if (liveChart) {
        liveChart.data.labels = labels;
        liveChart.data.datasets[0].data = upData;
        liveChart.data.datasets[1].data = dnData;
        liveChart.update();
        return;
      }

      liveChart = new Chart(document.getElementById('liveCanvas'), {
        type: 'line',
        data: {
          labels,
          datasets: [
            { label: 'UP', data: upData, borderColor: '#34d399', borderWidth: 1.5, pointRadius: 0, tension: 0.1 },
            { label: 'DN', data: dnData, borderColor: '#f87171', borderWidth: 1.5, pointRadius: 0, tension: 0.1 }
          ]
        },
        options: {
          responsive: true,
          animation: false,
          plugins: {
            legend: { display: true, labels: { color: '#71717a', font: { family: 'JetBrains Mono', size: 10 } } },
            tooltip: { callbacks: { label: ctx => ctx.dataset.label + ': ' + ctx.parsed.y + '\u00A2' } }
          },
          scales: {
            x: {
              ticks: { color: '#71717a', font: { family: 'JetBrains Mono', size: 9 }, maxTicksLimit: 6, maxRotation: 0 },
              grid: { color: 'rgba(255,255,255,0.04)' }
            },
            y: {
              min: 0, max: 100,
              ticks: { color: '#71717a', font: { family: 'JetBrains Mono', size: 10 }, callback: v => v + '\u00A2' },
              grid: { color: 'rgba(255,255,255,0.04)' }
            }
          }
        }
      });
    }

    function appendTickToChart(tick) {
      if (!liveChart) return;
      const time = new Date(tick['Timestamp']).toLocaleTimeString('en-US', {
        hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false, timeZone: 'America/New_York'
      });
      liveChart.data.labels.push(time);
      liveChart.data.datasets[0].data.push(Math.round(parseFloat(tick['UP Ask']) * 100));
      liveChart.data.datasets[1].data.push(Math.round(parseFloat(tick['DN Ask']) * 100));
      liveChart.update();
    }

    // â”€â”€ Event Feed â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function getEventStyle(evt) {
      if (evt === 'PROFIT_LOCK_FILLED') return { icon: '\uD83D\uDCB0', color: 'green' };
      if (/WIN|FILL|PROFIT/.test(evt)) return { icon: '\u2713', color: 'green' };
      if (/LOSS|ERROR|STOP|EXIT|FLATTEN/.test(evt)) return { icon: '\u2717', color: 'red' };
      if (/BAIL|HEDGE/.test(evt)) return { icon: '!', color: 'yellow' };
      return { icon: '\u00B7', color: 'muted' };
    }

    function formatEvent(e) {
      const evt = e['Event'] || '';
      const side = e['Side'] || '';
      const shares = e['Shares'];
      const price = e['Price'];
      const pnl = e['PnL'];
      switch (evt) {
        case 'CAPTURE_99C': return '99c snipe: ' + side + ' @ ' + Math.round(price * 100) + '\u00A2';
        case 'CAPTURE_FILL': return 'Filled: ' + shares + ' ' + side + ' @ ' + Math.round(price * 100) + '\u00A2';
        case 'PROFIT_LOCK_FILLED': return '\uD83D\uDCB0 Sold ' + shares + ' ' + side + ' @ 99\u00A2 â€” profit locked';
        case 'CAPTURE_99C_WIN': return 'WIN +$' + parseFloat(pnl || 0).toFixed(2);
        case 'CAPTURE_99C_LOSS': return 'LOSS -$' + Math.abs(parseFloat(pnl || 0)).toFixed(2);
        case '99C_EARLY_EXIT': return 'Early exit: ' + side;
        case 'HARD_STOP_EXIT': return 'Hard stop: ' + side;
        case 'WINDOW_START': return 'New window';
        case 'BALANCE_SNAPSHOT': return 'Balance snapshot';
        case 'PROFIT_PAIR': return 'Profit +$' + parseFloat(pnl || 0).toFixed(2);
        case 'ERROR': return 'Error: ' + String(e['Details'] || '').substring(0, 50);
        default: return evt + (side ? ' ' + side : '');
      }
    }

    function renderEventFeed() {
      const container = document.getElementById('live-events');
      if (!liveEvents.length) {
        container.innerHTML = '<p class="empty-state">No recent events</p>';
        return;
      }
      container.innerHTML = liveEvents.map(e => {
        const time = new Date(e['Timestamp']).toLocaleTimeString('en-US', {
          hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false, timeZone: 'America/New_York'
        });
        const { icon, color } = getEventStyle(e['Event'] || '');
        return '<div class="event-item">' +
          '<span class="event-time">' + time + '</span>' +
          '<span class="event-icon">' + icon + '</span>' +
          '<span class="event-text ' + color + '">' + escapeHtml(formatEvent(e)) + '</span>' +
        '</div>';
      }).join('');
    }

    function prependEvent(eventRow) {
      liveEvents.unshift(eventRow);
      if (liveEvents.length > 25) liveEvents.pop();
      if (activeTab === 'live') renderEventFeed();
    }

    // â”€â”€ End Live Status â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    // â”€â”€ Paper Trading Tab â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    let paperDataLoaded = false;

    async function loadPaperData() {
      try {
        console.log('[PAPER] Loading paper trading data...');

        // Fetch all relevant paper events in parallel
        const [fillsRes, exitsRes, winsRes, lossesRes] = await Promise.all([
          db.from('Polymarket Bot Log - Events').select('*')
            .eq('Event', 'PAPER_CAPTURE_FILL')
            .order('Timestamp', { ascending: false }),
          db.from('Polymarket Bot Log - Events').select('*')
            .eq('Event', 'PAPER_99C_EARLY_EXIT')
            .order('Timestamp', { ascending: false }),
          db.from('Polymarket Bot Log - Events').select('*')
            .eq('Event', 'PAPER_CAPTURE_99C_WIN')
            .order('Timestamp', { ascending: false }),
          db.from('Polymarket Bot Log - Events').select('*')
            .eq('Event', 'PAPER_CAPTURE_99C_LOSS')
            .order('Timestamp', { ascending: false })
        ]);

        const fills = fillsRes.data || [];
        const exits = exitsRes.data || [];
        const wins = winsRes.data || [];
        const losses = lossesRes.data || [];

        console.log(`[PAPER] ${fills.length} fills, ${exits.length} exits, ${wins.length} wins, ${losses.length} losses`);

        // Build lookup maps by Window ID
        const exitMap = {};
        for (const e of exits) exitMap[e['Window ID']] = e;
        const winSet = new Set(wins.map(w => w['Window ID']));
        const lossSet = new Set(losses.map(l => l['Window ID']));

        // Build paper trades from fills
        const paperTrades = [];
        for (const fill of fills) {
          const wid = fill['Window ID'] || '';
          const side = fill['Side'] || '';
          const shares = parseFloat(fill['Shares']) || 0;
          const price = parseFloat(fill['Price']) || 0;
          const cost = shares * price;
          const exitEvent = exitMap[wid];
          const age = (Date.now() - new Date(fill['Timestamp']).getTime()) / 1000;

          let status, pnl, exitPrice;

          if (exitEvent) {
            // Early exit â€” compute P&L from entry vs exit price
            exitPrice = parseFloat(exitEvent['Price']) || 0;
            pnl = Math.round((shares * exitPrice - cost) * 100) / 100;
            status = (pnl > 0 && exitPrice >= 0.98) ? 'CASHED' : 'EXIT';
          } else if (winSet.has(wid)) {
            // Explicit WIN event
            pnl = Math.round(shares * (1 - price) * 100) / 100;
            status = 'WIN';
          } else if (lossSet.has(wid)) {
            // Explicit LOSS event
            pnl = -Math.round(cost * 100) / 100;
            status = 'LOSS';
          } else if (age > 1200) {
            // Window closed (>20 min) but no explicit outcome â€” assume WIN
            // (99c captures at 95%+ confidence usually win)
            pnl = Math.round(shares * (1 - price) * 100) / 100;
            status = 'WIN';
          } else {
            pnl = 0;
            status = 'PENDING';
          }

          // Parse confidence from corresponding PAPER_CAPTURE_99C event
          let confidence = null;
          const detailStr = fill['Details'] || '';
          const confMatch = detailStr.match(/confidence['":\s]+([\d.]+)/);
          if (confMatch) confidence = parseFloat(confMatch[1]);

          paperTrades.push({
            timestamp: fill['Timestamp'],
            window_id: wid,
            side,
            shares,
            entry_price: price,
            exit_price: exitPrice,
            status,
            profit_loss: pnl,
            cost_basis: Math.round(cost * 100) / 100,
            confidence
          });
        }

        paperDataLoaded = true;
        renderPaperDashboard(paperTrades);
      } catch (e) {
        console.error('[PAPER] Error loading data:', e);
        document.getElementById('paperTrades').innerHTML =
          '<p class="empty-state">Error loading paper trades</p>';
      }
    }

    function renderPaperDashboard(trades) {
      // Summary stats
      const resolved = trades.filter(t => t.status !== 'PENDING');
      const winTrades = trades.filter(t => t.status === 'WIN');
      const cashedTrades = trades.filter(t => t.status === 'CASHED');
      const lossTrades = trades.filter(t => t.status === 'LOSS');
      const exitTrades = trades.filter(t => t.status === 'EXIT');
      const totalPnl = trades.reduce((s, t) => s + t.profit_loss, 0);

      const pnlEl = document.getElementById('paperPnl');
      pnlEl.textContent = fmtPnl(totalPnl);
      pnlEl.className = 'stat-value ' + (totalPnl >= 0 ? 'positive' : totalPnl < 0 ? 'negative' : 'neutral');

      const wrEl = document.getElementById('paperWinRate');
      const totalWins = winTrades.length + cashedTrades.length;
      const resolvedCount = totalWins + lossTrades.length + exitTrades.length;
      const winPct = resolvedCount > 0 ? Math.round(totalWins / resolvedCount * 100) : 0;
      wrEl.textContent = trades.length > 0 ? winPct + '%' : '--';
      wrEl.className = 'stat-value ' + (winPct >= 50 ? 'positive' : 'neutral');

      let recordText = winTrades.length + 'W';
      if (cashedTrades.length > 0) recordText += ' / ' + cashedTrades.length + 'C';
      recordText += ' / ' + lossTrades.length + 'L';
      if (exitTrades.length > 0) recordText += ' / ' + exitTrades.length + 'E';
      const pendingCount = trades.filter(t => t.status === 'PENDING').length;
      if (pendingCount > 0) recordText += ' (' + pendingCount + ' pending)';
      document.getElementById('paperRecord').textContent = trades.length > 0 ? recordText : 'No trades yet';

      // Trade list
      const container = document.getElementById('paperTrades');
      if (trades.length === 0) {
        container.innerHTML = '<p class="empty-state">No paper trades yet</p>';
        return;
      }

      let lastDate = null;
      container.innerHTML = trades.map(t => {
        const status = t.status;
        const pnl = t.profit_loss;
        const isPending = status === 'PENDING';
        const isWin = status === 'WIN';
        const isCashed = status === 'CASHED';
        const isExit = status === 'EXIT';
        const price = fmtPrice(t.entry_price);
        const tradeDate = new Date(t.timestamp);
        const time = tradeDate.toLocaleTimeString('en-US', {
          hour: 'numeric', minute: '2-digit', hour12: true, timeZone: 'America/New_York'
        });
        const dateStr = tradeDate.toLocaleDateString('en-CA', { timeZone: 'America/New_York' });
        const side = escapeHtml(t.side);
        const shares = t.shares % 1 < 0.01 ? Math.round(t.shares) : t.shares.toFixed(2);

        const statusClass = isPending ? 'pending' : isCashed ? 'profit-lock' : isExit ? 'paper-exit' : (isWin ? 'win' : 'loss');
        const statusIcon = isPending ? '\u25F7' : isCashed ? '\uD83D\uDCB0' : isExit ? '\u21A9' : (isWin ? '\u2713' : '\u2717');
        const pnlClass = isPending ? 'pending' : isCashed ? 'positive' : isExit ? 'paper-exit' : (isWin ? 'positive' : 'negative');
        const pnlText = isPending ? 'pending' : fmtPnl(pnl);

        let separator = '';
        if (lastDate !== dateStr) {
          const displayDate = tradeDate.toLocaleDateString('en-US', {
            weekday: 'short', month: 'short', day: 'numeric', timeZone: 'America/New_York'
          });
          separator = '<div class="date-separator">' + displayDate + '</div>';
          lastDate = dateStr;
        }

        const confText = t.confidence ? Math.round(t.confidence * 100) + '% conf' : '';
        const exitText = (isExit || isCashed) && t.exit_price ? ' \u2192 ' + fmtPrice(t.exit_price) : '';

        return separator + `
          <div class="trade-item">
            <div class="trade-status ${statusClass}">${statusIcon}</div>
            <div class="trade-info">
              <div class="trade-pair">${side} ${shares}@${price}${exitText}</div>
              <div class="trade-detail">$${t.cost_basis.toFixed(2)}${confText ? ' \u00B7 ' + confText : ''}</div>
              <div class="trade-meta">${time}</div>
            </div>
            <div class="trade-pnl ${pnlClass}">${pnlText}</div>
          </div>
        `;
      }).join('');
    }

    // â”€â”€ End Paper Trading â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    // â”€â”€ 90c Test Tab â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async function load90cTestData() {
      try {
        console.log('[90C] Loading 90c test trades...');
        const activityUrl = `https://data-api.polymarket.com/activity?user=${CONFIG.walletAddress}&limit=1000`;
        const resp = await fetch(activityUrl);
        if (!resp.ok) throw new Error('Activity API error');
        const allActivity = await resp.json();

        // Only show today's trades (EST) and forward
        const nowEST = new Date().toLocaleDateString('en-CA', { timeZone: 'America/New_York' });
        const todayCutoff = new Date(nowEST + 'T00:00:00-05:00').getTime() / 1000;
        const todayActivity = allActivity.filter(a => a.timestamp >= todayCutoff);

        // 90c bot buys are 5-8 shares each
        const is90cBuy = (a) => a.type === 'TRADE' && a.side === 'BUY' && parseFloat(a.size) > 5 && parseFloat(a.size) < 8;
        const buys = todayActivity.filter(is90cBuy);
        const sells = todayActivity.filter(a => a.type === 'TRADE' && a.side === 'SELL');
        const redeems = todayActivity.filter(a => a.type === 'REDEEM');
        // Match redeems by conditionId only (redeems use outcomeIndex=999, not 0/1)
        const redeemSet = new Set(redeems.map(r => r.conditionId || ''));

        // Group buys by window slug+outcome (combine multiple fills into one trade)
        const grouped = {};
        for (const buy of buys) {
          const key = (buy.slug || '') + '|' + (buy.outcomeIndex ?? '');
          if (!grouped[key]) grouped[key] = { buys: [], slug: buy.slug || '', outcomeIndex: buy.outcomeIndex, conditionId: buy.conditionId };
          grouped[key].buys.push(buy);
        }

        // Build sell map by conditionId+outcomeIndex (all sells â€” capped at buy total later)
        const sellMap = {};
        for (const s of sells) {
          const key = (s.conditionId || '') + '|' + (s.outcomeIndex ?? '');
          if (!sellMap[key]) sellMap[key] = [];
          sellMap[key].push(s);
        }

        // Build one trade per window (skip runaway groups with >20 total shares)
        const trades = [];
        for (const [key, group] of Object.entries(grouped)) {
          const allBuys = group.buys;
          const totalShares = allBuys.reduce((s, b) => s + parseFloat(b.size), 0);
          if (totalShares > 20) continue; // Skip runaway fills
          const totalCost = allBuys.reduce((s, b) => s + parseFloat(b.price) * parseFloat(b.size), 0);
          const avgPrice = totalCost / totalShares;
          const firstTs = Math.min(...allBuys.map(b => b.timestamp));
          const age = Date.now() / 1000 - firstTs;
          const condId = group.conditionId || '';
          const condKey = condId + '|' + (group.outcomeIndex ?? '');
          const won = redeemSet.has(condId);
          const side = group.outcomeIndex === '0' ? 'UP' : 'DN';

          // Check for sells (profit lock / exits) â€” cap at totalShares to avoid 95c bot bleed
          let exitRevenue = 0, exitShares = 0;
          if (sellMap[condKey]) {
            for (const s of sellMap[condKey]) {
              if (exitShares >= totalShares) break;
              if (s.timestamp >= firstTs && s.timestamp <= firstTs + 1200) {
                const canMatch = Math.min(parseFloat(s.size), totalShares - exitShares);
                exitRevenue += parseFloat(s.price) * canMatch;
                exitShares += canMatch;
              }
            }
          }

          const exitedAll = exitShares >= totalShares * 0.9;
          if (exitedAll && exitShares > 0) {
            const pnl = exitRevenue - totalCost;
            const exitPrice = exitRevenue / exitShares;
            const isCashedOut = pnl > 0 && exitPrice >= 0.98;
            trades.push({
              timestamp: new Date(firstTs * 1000).toISOString(),
              window_id: group.slug, side, fills: allBuys.length,
              shares: Math.round(totalShares * 100) / 100, entry_price: Math.round(avgPrice * 100) / 100, exit_price: exitPrice,
              status: isCashedOut ? 'CASHED' : 'EXIT',
              profit_loss: Math.round(pnl * 100) / 100,
              cost_basis: Math.round(totalCost * 100) / 100
            });
          } else {
            const status = won ? 'WIN' : (age > 1800 ? 'LOSS' : 'PENDING');
            const pnl = status === 'WIN' ? totalShares * (1 - avgPrice) : (status === 'LOSS' ? -totalCost : 0);
            trades.push({
              timestamp: new Date(firstTs * 1000).toISOString(),
              window_id: group.slug, side, fills: allBuys.length,
              shares: Math.round(totalShares * 100) / 100, entry_price: Math.round(avgPrice * 100) / 100,
              status,
              profit_loss: Math.round(pnl * 100) / 100,
              cost_basis: Math.round(totalCost * 100) / 100
            });
          }
        }

        trades.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        test90cDataLoaded = true;
        render90cTestDashboard(trades);
      } catch (e) {
        console.error('[90C] Error:', e);
        document.getElementById('test90cTrades').innerHTML =
          '<p class="empty-state">Error loading 90c test trades</p>';
      }
    }

    function windowTimeFromSlug(slug) {
      // slug format: "btc-updown-15m-1772382600" â†’ extract unix timestamp of window end
      const m = (slug || '').match(/(\d{10,})$/);
      if (!m) return null;
      const endTs = parseInt(m[1]) * 1000;
      const startTs = endTs - 15 * 60 * 1000;
      const fmt = (d) => d.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true, timeZone: 'America/New_York' });
      return fmt(new Date(startTs)) + '-' + fmt(new Date(endTs)) + ' ET';
    }

    function render90cTestDashboard(trades) {
      const resolved = trades.filter(t => t.status !== 'PENDING');
      const winTrades = trades.filter(t => t.status === 'WIN');
      const cashedTrades = trades.filter(t => t.status === 'CASHED');
      const lossTrades = trades.filter(t => t.status === 'LOSS');
      const exitTrades = trades.filter(t => t.status === 'EXIT');
      const totalPnl = trades.reduce((s, t) => s + t.profit_loss, 0);

      const pnlEl = document.getElementById('test90cPnl');
      pnlEl.textContent = fmtPnl(totalPnl);
      pnlEl.className = 'stat-value ' + (totalPnl >= 0 ? 'positive' : totalPnl < 0 ? 'negative' : 'neutral');

      const wrEl = document.getElementById('test90cWinRate');
      const totalWins = winTrades.length + cashedTrades.length;
      const resolvedCount = totalWins + lossTrades.length + exitTrades.length;
      const winPct = resolvedCount > 0 ? Math.round(totalWins / resolvedCount * 100) : 0;
      wrEl.textContent = trades.length > 0 ? winPct + '%' : '--';
      wrEl.className = 'stat-value ' + (winPct >= 50 ? 'positive' : 'neutral');

      let recordText = winTrades.length + 'W';
      if (cashedTrades.length > 0) recordText += ' / ' + cashedTrades.length + 'C';
      recordText += ' / ' + lossTrades.length + 'L';
      if (exitTrades.length > 0) recordText += ' / ' + exitTrades.length + 'E';
      const pendingCount = trades.filter(t => t.status === 'PENDING').length;
      if (pendingCount > 0) recordText += ' (' + pendingCount + ' pending)';
      document.getElementById('test90cRecord').textContent = trades.length > 0 ? recordText : 'No trades yet';

      const totalCost = trades.reduce((s, t) => s + (t.cost_basis ?? 0), 0);
      const avgTradeCost = trades.length > 0 ? totalCost / trades.length : 0;
      const roiPct = avgTradeCost > 0 ? Math.round(totalPnl / avgTradeCost * 1000) / 10 : 0;
      const roiEl = document.getElementById('test90cRoi');
      roiEl.textContent = trades.length > 0 ? (roiPct > 0 ? '+' : '') + roiPct + '% ROI' : '';
      roiEl.className = 'stat-roi ' + (roiPct >= 0 ? 'positive' : 'negative');

      // â”€â”€ Trade list â”€â”€
      const container = document.getElementById('test90cTrades');
      if (trades.length === 0) {
        container.innerHTML = '<p class="empty-state">No 90c test trades yet â€” bot not launched</p>';
        render90cHistory([]);
        return;
      }

      let lastDate = null;
      container.innerHTML = trades.map(t => {
        const status = t.status;
        const pnl = t.profit_loss;
        const isPending = status === 'PENDING';
        const isWin = status === 'WIN';
        const isCashed = status === 'CASHED';
        const isExit = status === 'EXIT';
        const price = fmtPrice(t.entry_price);
        const tradeDate = new Date(t.timestamp);
        const dateStr = tradeDate.toLocaleDateString('en-CA', { timeZone: 'America/New_York' });
        const side = escapeHtml(t.side);
        const shares = t.shares % 1 < 0.01 ? Math.round(t.shares) : t.shares.toFixed(2);

        const statusClass = isPending ? 'pending' : isCashed ? 'profit-lock' : isExit ? 'exit' : (isWin ? 'win' : 'loss');
        const statusIcon = isPending ? '\u25F7' : isCashed ? '\uD83D\uDCB0' : isExit ? '\u21A9' : (isWin ? '\u2713' : '\u2717');
        const pnlClass = isPending ? 'pending' : isCashed ? 'positive' : isExit ? 'exit' : (isWin ? 'positive' : 'negative');
        const pnlText = isPending ? 'pending' : fmtPnl(pnl);
        const exitText = (isExit || isCashed) && t.exit_price ? ' \u2192 ' + fmtPrice(t.exit_price) : '';

        // ROI% per trade
        const cb = t.cost_basis || 0;
        const tradeRoi = cb > 0 && !isPending ? Math.round(pnl / cb * 1000) / 10 : null;
        const roiHtml = tradeRoi !== null ? `<span class="roi ${tradeRoi >= 0 ? 'positive' : 'negative'}">${tradeRoi > 0 ? '+' : ''}${tradeRoi}%</span>` : '--';

        // Window timeframe from slug
        const windowTime = windowTimeFromSlug(t.window_id);
        const metaText = windowTime || tradeDate.toLocaleTimeString('en-US', {
          hour: 'numeric', minute: '2-digit', hour12: true, timeZone: 'America/New_York'
        });

        let separator = '';
        if (lastDate !== dateStr) {
          const displayDate = tradeDate.toLocaleDateString('en-US', {
            weekday: 'short', month: 'short', day: 'numeric', timeZone: 'America/New_York'
          });
          separator = '<div class="date-separator">' + displayDate + '</div>';
          lastDate = dateStr;
        }

        return separator + `
          <div class="trade-item">
            <div class="trade-status ${statusClass}">${statusIcon}</div>
            <div class="trade-info">
              <div class="trade-pair">${side} ${shares}@${price}${exitText}</div>
              <div class="trade-detail">$${cb.toFixed(2)} \u00b7 ${roiHtml}</div>
              <div class="trade-meta">${metaText}</div>
            </div>
            <div class="trade-pnl ${pnlClass}">${pnlText}</div>
          </div>
        `;
      }).join('');

      // â”€â”€ Daily history â”€â”€
      render90cHistory(trades);
    }

    function render90cHistory(trades) {
      const histEl = document.getElementById('test90cHistory');
      if (!trades.length) { histEl.innerHTML = '<p class="empty-state">No history yet</p>'; return; }

      // Group by date (EST)
      const byDate = {};
      for (const t of trades) {
        const d = new Date(t.timestamp).toLocaleDateString('en-CA', { timeZone: 'America/New_York' });
        if (!byDate[d]) byDate[d] = [];
        byDate[d].push(t);
      }

      const dates = Object.keys(byDate).sort().reverse();
      histEl.innerHTML = dates.map(date => {
        const dayTrades = byDate[date];
        const wins = dayTrades.filter(t => t.status === 'WIN' || t.status === 'CASHED').length;
        const losses = dayTrades.filter(t => t.status === 'LOSS').length;
        const exits = dayTrades.filter(t => t.status === 'EXIT').length;
        const pending = dayTrades.filter(t => t.status === 'PENDING').length;
        const pnl = dayTrades.reduce((s, t) => s + t.profit_loss, 0);
        const cost = dayTrades.reduce((s, t) => s + (t.cost_basis ?? 0), 0);
        const roi = cost > 0 ? Math.round(pnl / cost * 1000) / 10 : 0;
        const total = wins + losses + exits;
        const wr = total > 0 ? Math.round(wins / total * 100) : 0;

        const displayDate = new Date(date + 'T12:00:00').toLocaleDateString('en-US', {
          weekday: 'short', month: 'short', day: 'numeric'
        });
        const pnlClass = pnl >= 0 ? 'positive' : 'negative';
        let record = wins + 'W / ' + losses + 'L';
        if (exits > 0) record += ' / ' + exits + 'E';
        if (pending > 0) record += ' (' + pending + 'P)';

        return `
          <div class="trade-item">
            <div class="trade-info" style="flex:1">
              <div class="trade-pair">${displayDate}</div>
              <div class="trade-detail">${record} \u00b7 ${wr}% WR \u00b7 <span class="roi ${roi >= 0 ? 'positive' : 'negative'}">${roi > 0 ? '+' : ''}${roi}% ROI</span></div>
            </div>
            <div class="trade-pnl ${pnlClass}">${fmtPnl(pnl)}</div>
          </div>
        `;
      }).join('');
    }

    // â”€â”€ End 90c Test â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    // Toggle between today's trades and all historical trades
    document.getElementById('tradesToggle').addEventListener('click', () => {
      showingAll = !showingAll;
      const trades = showingAll ? allTrades : getTodayTrades();
      renderDashboard(currentSummary, trades);
      document.getElementById('tradesToggle').textContent = showingAll ? 'TODAY' : 'SHOW ALL';
      document.querySelector('.section-title').textContent = showingAll ? 'All Trades' : "Today's Trades";
    });

    // Expand/collapse window fill groups
    el.trades.addEventListener('click', (e) => {
      const summary = e.target.closest('.window-summary');
      if (!summary) return;
      summary.classList.toggle('expanded');
      const fills = summary.nextElementSibling;
      if (fills && fills.classList.contains('window-fills')) {
        fills.classList.toggle('open');
      }
    });

    // Initial load and setup
    fetchStartingBalance().then(() => loadData()).then(() => {
      setupRealtime();
    }).catch(() => {
      setupRealtime();
    });
  </script>
</body>
</html>
